// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/game/types/types.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	game "github.com/kubegames/kubegames-hall/app/model/game"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//添加游戏请求
type AddGameRequest struct {
	//游戏ID
	GameID uint32 `protobuf:"varint,1,opt,name=gameID,proto3" json:"gameID,omitempty" binding:"required"`
	//游戏名称
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" binding:"required"`
	//房间配置
	Config               *GameConfig `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty" binding:"required"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte      `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32       `json:"-" xorm:"-" gorm:"-"`
}

func (m *AddGameRequest) Reset()         { *m = AddGameRequest{} }
func (m *AddGameRequest) String() string { return proto.CompactTextString(m) }
func (*AddGameRequest) ProtoMessage()    {}
func (*AddGameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{0}
}
func (m *AddGameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddGameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddGameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddGameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddGameRequest.Merge(m, src)
}
func (m *AddGameRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddGameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddGameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddGameRequest proto.InternalMessageInfo

//游戏配置请求
type GameConfig struct {
	//游戏大厅地址
	Platform string `protobuf:"bytes,1,opt,name=platform,proto3" json:"platform,omitempty" binding:"required"`
	//最多进入人数
	MaxPeople uint32 `protobuf:"varint,2,opt,name=maxPeople,proto3" json:"maxPeople,omitempty" binding:"required"`
	//运行模式
	Runmode              string   `protobuf:"bytes,3,opt,name=runmode,proto3" json:"runmode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *GameConfig) Reset()         { *m = GameConfig{} }
func (m *GameConfig) String() string { return proto.CompactTextString(m) }
func (*GameConfig) ProtoMessage()    {}
func (*GameConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{1}
}
func (m *GameConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameConfig.Merge(m, src)
}
func (m *GameConfig) XXX_Size() int {
	return m.Size()
}
func (m *GameConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GameConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GameConfig proto.InternalMessageInfo

//添加游戏响应
type AddGameResponse struct {
	//success
	Success              bool     `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *AddGameResponse) Reset()         { *m = AddGameResponse{} }
func (m *AddGameResponse) String() string { return proto.CompactTextString(m) }
func (*AddGameResponse) ProtoMessage()    {}
func (*AddGameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{2}
}
func (m *AddGameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddGameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddGameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddGameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddGameResponse.Merge(m, src)
}
func (m *AddGameResponse) XXX_Size() int {
	return m.Size()
}
func (m *AddGameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddGameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddGameResponse proto.InternalMessageInfo

//启动游戏服务请求
type StartGameRequest struct {
	//游戏ID
	GameID uint32 `protobuf:"varint,1,opt,name=gameID,proto3" json:"gameID,omitempty" binding:"required"`
	//镜像
	Image string `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty" binding:"required"`
	//运行副本数
	Replicas uint32 `protobuf:"varint,3,opt,name=replicas,proto3" json:"replicas,omitempty" binding:"required"`
	//端口
	Port uint32 `protobuf:"varint,4,opt,name=port,proto3" json:"port,omitempty" binding:"required"`
	//启动命令
	Commonds []string `protobuf:"bytes,6,rep,name=commonds,proto3" json:"commonds,omitempty"`
	//最大可用 cpu (1000 = 1cpu)
	Cpu uint32 `protobuf:"varint,7,opt,name=cpu,proto3" json:"cpu,omitempty"`
	//最大可用内存 memory (1=1Mi)
	Memory               uint32   `protobuf:"varint,8,opt,name=memory,proto3" json:"memory,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *StartGameRequest) Reset()         { *m = StartGameRequest{} }
func (m *StartGameRequest) String() string { return proto.CompactTextString(m) }
func (*StartGameRequest) ProtoMessage()    {}
func (*StartGameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{3}
}
func (m *StartGameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartGameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartGameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartGameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartGameRequest.Merge(m, src)
}
func (m *StartGameRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartGameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartGameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartGameRequest proto.InternalMessageInfo

//启动游戏响应
type StartGameResponse struct {
	//success
	Success              bool     `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *StartGameResponse) Reset()         { *m = StartGameResponse{} }
func (m *StartGameResponse) String() string { return proto.CompactTextString(m) }
func (*StartGameResponse) ProtoMessage()    {}
func (*StartGameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{4}
}
func (m *StartGameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartGameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartGameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartGameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartGameResponse.Merge(m, src)
}
func (m *StartGameResponse) XXX_Size() int {
	return m.Size()
}
func (m *StartGameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartGameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartGameResponse proto.InternalMessageInfo

//关闭游戏请求
type CloseGameRequest struct {
	//游戏ID
	GameID               uint32   `protobuf:"varint,1,opt,name=gameID,proto3" json:"gameID,omitempty" uri:"gameID" binding:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *CloseGameRequest) Reset()         { *m = CloseGameRequest{} }
func (m *CloseGameRequest) String() string { return proto.CompactTextString(m) }
func (*CloseGameRequest) ProtoMessage()    {}
func (*CloseGameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{5}
}
func (m *CloseGameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseGameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseGameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloseGameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseGameRequest.Merge(m, src)
}
func (m *CloseGameRequest) XXX_Size() int {
	return m.Size()
}
func (m *CloseGameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseGameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CloseGameRequest proto.InternalMessageInfo

//关闭游戏响应
type CloseGameResponse struct {
	//success
	Success              bool     `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *CloseGameResponse) Reset()         { *m = CloseGameResponse{} }
func (m *CloseGameResponse) String() string { return proto.CompactTextString(m) }
func (*CloseGameResponse) ProtoMessage()    {}
func (*CloseGameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{6}
}
func (m *CloseGameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseGameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseGameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloseGameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseGameResponse.Merge(m, src)
}
func (m *CloseGameResponse) XXX_Size() int {
	return m.Size()
}
func (m *CloseGameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseGameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CloseGameResponse proto.InternalMessageInfo

//查询游戏请求
type FindGameRequest struct {
	//游戏ID
	GameID               uint32   `protobuf:"varint,1,opt,name=gameID,proto3" json:"gameID,omitempty" uri:"gameID" binding:"required"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *FindGameRequest) Reset()         { *m = FindGameRequest{} }
func (m *FindGameRequest) String() string { return proto.CompactTextString(m) }
func (*FindGameRequest) ProtoMessage()    {}
func (*FindGameRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{7}
}
func (m *FindGameRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindGameRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindGameRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindGameRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindGameRequest.Merge(m, src)
}
func (m *FindGameRequest) XXX_Size() int {
	return m.Size()
}
func (m *FindGameRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FindGameRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FindGameRequest proto.InternalMessageInfo

//查询游戏响应
type FindGameResponse struct {
	Game                 *game.Game `protobuf:"bytes,1,opt,name=Game,proto3" json:"Game,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte     `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32      `json:"-" xorm:"-" gorm:"-"`
}

func (m *FindGameResponse) Reset()         { *m = FindGameResponse{} }
func (m *FindGameResponse) String() string { return proto.CompactTextString(m) }
func (*FindGameResponse) ProtoMessage()    {}
func (*FindGameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{8}
}
func (m *FindGameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindGameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindGameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindGameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindGameResponse.Merge(m, src)
}
func (m *FindGameResponse) XXX_Size() int {
	return m.Size()
}
func (m *FindGameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FindGameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FindGameResponse proto.InternalMessageInfo

//查询游戏列表
type FindGamesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *FindGamesRequest) Reset()         { *m = FindGamesRequest{} }
func (m *FindGamesRequest) String() string { return proto.CompactTextString(m) }
func (*FindGamesRequest) ProtoMessage()    {}
func (*FindGamesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{9}
}
func (m *FindGamesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindGamesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindGamesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindGamesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindGamesRequest.Merge(m, src)
}
func (m *FindGamesRequest) XXX_Size() int {
	return m.Size()
}
func (m *FindGamesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FindGamesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FindGamesRequest proto.InternalMessageInfo

//查询游戏列表响应
type FindGamesResponse struct {
	Games                []*game.Game `protobuf:"bytes,1,rep,name=Games,proto3" json:"Games,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte       `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32        `json:"-" xorm:"-" gorm:"-"`
}

func (m *FindGamesResponse) Reset()         { *m = FindGamesResponse{} }
func (m *FindGamesResponse) String() string { return proto.CompactTextString(m) }
func (*FindGamesResponse) ProtoMessage()    {}
func (*FindGamesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_181c686bf6bc1527, []int{10}
}
func (m *FindGamesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindGamesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindGamesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindGamesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindGamesResponse.Merge(m, src)
}
func (m *FindGamesResponse) XXX_Size() int {
	return m.Size()
}
func (m *FindGamesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FindGamesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FindGamesResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AddGameRequest)(nil), "game_types.AddGameRequest")
	proto.RegisterType((*GameConfig)(nil), "game_types.GameConfig")
	proto.RegisterType((*AddGameResponse)(nil), "game_types.AddGameResponse")
	proto.RegisterType((*StartGameRequest)(nil), "game_types.StartGameRequest")
	proto.RegisterType((*StartGameResponse)(nil), "game_types.StartGameResponse")
	proto.RegisterType((*CloseGameRequest)(nil), "game_types.CloseGameRequest")
	proto.RegisterType((*CloseGameResponse)(nil), "game_types.CloseGameResponse")
	proto.RegisterType((*FindGameRequest)(nil), "game_types.FindGameRequest")
	proto.RegisterType((*FindGameResponse)(nil), "game_types.FindGameResponse")
	proto.RegisterType((*FindGamesRequest)(nil), "game_types.FindGamesRequest")
	proto.RegisterType((*FindGamesResponse)(nil), "game_types.FindGamesResponse")
}

func init() {
	proto.RegisterFile("app/service/game/types/types.proto", fileDescriptor_181c686bf6bc1527)
}

var fileDescriptor_181c686bf6bc1527 = []byte{
	// 551 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0x4f, 0x6e, 0xd3, 0x4e,
	0x14, 0xc7, 0x3b, 0x4d, 0x9b, 0x26, 0xaf, 0xfa, 0xfd, 0x9a, 0xce, 0x22, 0x32, 0x59, 0x38, 0xd6,
	0x80, 0x50, 0x04, 0xd4, 0x96, 0x02, 0x0b, 0x94, 0xae, 0x68, 0x51, 0x11, 0x1b, 0x40, 0x66, 0x83,
	0xd8, 0x54, 0xfe, 0x33, 0x71, 0x47, 0x78, 0x3c, 0xee, 0x8c, 0x8d, 0xe8, 0x2d, 0x58, 0x21, 0x8e,
	0xc0, 0x01, 0x38, 0x44, 0x97, 0x9c, 0xa0, 0x6a, 0xc3, 0x0d, 0x7a, 0x02, 0x34, 0xe3, 0x34, 0x8e,
	0x50, 0x4d, 0x16, 0xb0, 0xb1, 0xe6, 0xbd, 0xf7, 0x99, 0xef, 0x7b, 0xf3, 0xb5, 0x66, 0x80, 0x04,
	0x79, 0xee, 0x29, 0x2a, 0x3f, 0xb2, 0x88, 0x7a, 0x49, 0xc0, 0xa9, 0x57, 0x9c, 0xe5, 0x54, 0x55,
	0x5f, 0x37, 0x97, 0xa2, 0x10, 0x18, 0x74, 0xfe, 0xd8, 0x64, 0x06, 0x8e, 0xe6, 0x53, 0x16, 0x7a,
	0x89, 0x48, 0x84, 0x67, 0xea, 0x61, 0x39, 0x35, 0x51, 0x45, 0x0f, 0xee, 0x68, 0x82, 0x8b, 0x98,
	0xa6, 0x95, 0x9e, 0xfe, 0x54, 0x25, 0xf2, 0x1d, 0xc1, 0xff, 0xcf, 0xe2, 0xf8, 0x45, 0xc0, 0xa9,
	0x4f, 0x4f, 0x4b, 0xaa, 0x0a, 0xec, 0x42, 0x5b, 0x03, 0x2f, 0x9f, 0x5b, 0xc8, 0x41, 0xa3, 0xff,
	0x0e, 0xfa, 0xd7, 0x17, 0x43, 0x1c, 0xb2, 0x2c, 0x66, 0x59, 0x32, 0x21, 0x92, 0x9e, 0x96, 0x4c,
	0xd2, 0x98, 0xf8, 0x73, 0x0a, 0x3f, 0x80, 0x8d, 0x2c, 0xe0, 0xd4, 0x5a, 0x77, 0xd0, 0xa8, 0xdb,
	0x48, 0x1b, 0x06, 0x1f, 0x41, 0x3b, 0x12, 0xd9, 0x94, 0x25, 0x56, 0xcb, 0x41, 0xa3, 0xed, 0x71,
	0xdf, 0xad, 0x0f, 0xe2, 0xea, 0x21, 0x0e, 0x4d, 0xb5, 0xb9, 0x67, 0xb5, 0x9b, 0x7c, 0x46, 0x00,
	0x35, 0x8e, 0xc7, 0xd0, 0xc9, 0xd3, 0xa0, 0x98, 0x0a, 0xc9, 0xcd, 0xd0, 0xcd, 0x63, 0x2c, 0x38,
	0xfc, 0x04, 0xba, 0x3c, 0xf8, 0xf4, 0x86, 0x8a, 0x3c, 0xad, 0x66, 0x6f, 0x3e, 0x69, 0x0d, 0x62,
	0x0b, 0xb6, 0x64, 0x99, 0x69, 0x2f, 0xcd, 0x09, 0xba, 0xfe, 0x4d, 0x48, 0x1e, 0xc2, 0xce, 0xc2,
	0x48, 0x95, 0x8b, 0x4c, 0x19, 0x58, 0x95, 0x51, 0x44, 0x95, 0x32, 0x53, 0x75, 0xfc, 0x9b, 0x90,
	0x7c, 0x59, 0x87, 0xde, 0xdb, 0x22, 0x90, 0xc5, 0xdf, 0x18, 0xff, 0x08, 0x36, 0x19, 0x0f, 0x92,
	0x55, 0xce, 0x57, 0x90, 0xf6, 0x48, 0xd2, 0x3c, 0x65, 0x51, 0xa0, 0xcc, 0xe8, 0xcd, 0xfa, 0x0b,
	0x4e, 0xff, 0xda, 0x5c, 0xc8, 0xc2, 0xda, 0xf8, 0x23, 0x6f, 0x18, 0x3c, 0x80, 0x4e, 0x24, 0x38,
	0x17, 0x59, 0xac, 0xac, 0xb6, 0xd3, 0x1a, 0x75, 0xfd, 0x45, 0x8c, 0x7b, 0xd0, 0x8a, 0xf2, 0xd2,
	0xda, 0xd2, 0x32, 0xbe, 0x5e, 0xe2, 0x3e, 0xb4, 0x39, 0xe5, 0x42, 0x9e, 0x59, 0x1d, 0x93, 0x9c,
	0x47, 0x64, 0x0f, 0x76, 0x97, 0x7c, 0x59, 0xe9, 0xe3, 0x6b, 0xe8, 0x1d, 0xa6, 0x42, 0xd1, 0x65,
	0x1b, 0xf7, 0x7f, 0xb3, 0xf1, 0xee, 0xf5, 0xc5, 0x70, 0x58, 0x4a, 0x36, 0x21, 0x55, 0x9a, 0x38,
	0xcd, 0x9e, 0xea, 0xfe, 0x4b, 0x82, 0x2b, 0xfb, 0xbf, 0x82, 0x9d, 0x23, 0x96, 0xc5, 0xff, 0xac,
	0xfd, 0x53, 0xe8, 0xd5, 0x7a, 0xf3, 0xee, 0xf7, 0x60, 0x43, 0xc7, 0x46, 0x6e, 0x7b, 0xdc, 0x73,
	0xcd, 0x45, 0x3e, 0x36, 0x77, 0xd8, 0x70, 0xa6, 0x4a, 0x70, 0xbd, 0x53, 0xcd, 0x47, 0x21, 0xfb,
	0xb0, 0xbb, 0x94, 0x9b, 0xcb, 0xdd, 0x87, 0x4d, 0x93, 0xb0, 0x90, 0xd3, 0xba, 0x55, 0xaf, 0x2a,
	0x1f, 0xbc, 0x3b, 0xbf, 0xb2, 0xd7, 0x2e, 0xaf, 0x6c, 0xf4, 0x6d, 0x66, 0xa3, 0xf3, 0x99, 0x8d,
	0x7e, 0xcc, 0x6c, 0x74, 0x39, 0xb3, 0xd1, 0xd7, 0x9f, 0xf6, 0xda, 0xfb, 0x49, 0xc2, 0x8a, 0x93,
	0x32, 0x74, 0x23, 0xc1, 0xbd, 0x0f, 0x65, 0x48, 0xf5, 0x76, 0x55, 0xaf, 0xf6, 0x4e, 0x82, 0x34,
	0xf5, 0x6e, 0x7f, 0xc8, 0xc2, 0xb6, 0x79, 0x7a, 0x1e, 0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xc9,
	0x30, 0x44, 0xa3, 0xe9, 0x04, 0x00, 0x00,
}

func (this *AddGameRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AddGameRequest)
	if !ok {
		that2, ok := that.(AddGameRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AddGameRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AddGameRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AddGameRequest but is not nil && this == nil")
	}
	if this.GameID != that1.GameID {
		return fmt.Errorf("GameID this(%v) Not Equal that(%v)", this.GameID, that1.GameID)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if !this.Config.Equal(that1.Config) {
		return fmt.Errorf("Config this(%v) Not Equal that(%v)", this.Config, that1.Config)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *AddGameRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddGameRequest)
	if !ok {
		that2, ok := that.(AddGameRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GameID != that1.GameID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.Config.Equal(that1.Config) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GameConfig) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GameConfig)
	if !ok {
		that2, ok := that.(GameConfig)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GameConfig")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GameConfig but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GameConfig but is not nil && this == nil")
	}
	if this.Platform != that1.Platform {
		return fmt.Errorf("Platform this(%v) Not Equal that(%v)", this.Platform, that1.Platform)
	}
	if this.MaxPeople != that1.MaxPeople {
		return fmt.Errorf("MaxPeople this(%v) Not Equal that(%v)", this.MaxPeople, that1.MaxPeople)
	}
	if this.Runmode != that1.Runmode {
		return fmt.Errorf("Runmode this(%v) Not Equal that(%v)", this.Runmode, that1.Runmode)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GameConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GameConfig)
	if !ok {
		that2, ok := that.(GameConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Platform != that1.Platform {
		return false
	}
	if this.MaxPeople != that1.MaxPeople {
		return false
	}
	if this.Runmode != that1.Runmode {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *AddGameResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*AddGameResponse)
	if !ok {
		that2, ok := that.(AddGameResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *AddGameResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *AddGameResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *AddGameResponse but is not nil && this == nil")
	}
	if this.Success != that1.Success {
		return fmt.Errorf("Success this(%v) Not Equal that(%v)", this.Success, that1.Success)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *AddGameResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddGameResponse)
	if !ok {
		that2, ok := that.(AddGameResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *StartGameRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*StartGameRequest)
	if !ok {
		that2, ok := that.(StartGameRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *StartGameRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *StartGameRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *StartGameRequest but is not nil && this == nil")
	}
	if this.GameID != that1.GameID {
		return fmt.Errorf("GameID this(%v) Not Equal that(%v)", this.GameID, that1.GameID)
	}
	if this.Image != that1.Image {
		return fmt.Errorf("Image this(%v) Not Equal that(%v)", this.Image, that1.Image)
	}
	if this.Replicas != that1.Replicas {
		return fmt.Errorf("Replicas this(%v) Not Equal that(%v)", this.Replicas, that1.Replicas)
	}
	if this.Port != that1.Port {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	if len(this.Commonds) != len(that1.Commonds) {
		return fmt.Errorf("Commonds this(%v) Not Equal that(%v)", len(this.Commonds), len(that1.Commonds))
	}
	for i := range this.Commonds {
		if this.Commonds[i] != that1.Commonds[i] {
			return fmt.Errorf("Commonds this[%v](%v) Not Equal that[%v](%v)", i, this.Commonds[i], i, that1.Commonds[i])
		}
	}
	if this.Cpu != that1.Cpu {
		return fmt.Errorf("Cpu this(%v) Not Equal that(%v)", this.Cpu, that1.Cpu)
	}
	if this.Memory != that1.Memory {
		return fmt.Errorf("Memory this(%v) Not Equal that(%v)", this.Memory, that1.Memory)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *StartGameRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartGameRequest)
	if !ok {
		that2, ok := that.(StartGameRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GameID != that1.GameID {
		return false
	}
	if this.Image != that1.Image {
		return false
	}
	if this.Replicas != that1.Replicas {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if len(this.Commonds) != len(that1.Commonds) {
		return false
	}
	for i := range this.Commonds {
		if this.Commonds[i] != that1.Commonds[i] {
			return false
		}
	}
	if this.Cpu != that1.Cpu {
		return false
	}
	if this.Memory != that1.Memory {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *StartGameResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*StartGameResponse)
	if !ok {
		that2, ok := that.(StartGameResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *StartGameResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *StartGameResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *StartGameResponse but is not nil && this == nil")
	}
	if this.Success != that1.Success {
		return fmt.Errorf("Success this(%v) Not Equal that(%v)", this.Success, that1.Success)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *StartGameResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartGameResponse)
	if !ok {
		that2, ok := that.(StartGameResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CloseGameRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CloseGameRequest)
	if !ok {
		that2, ok := that.(CloseGameRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CloseGameRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CloseGameRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CloseGameRequest but is not nil && this == nil")
	}
	if this.GameID != that1.GameID {
		return fmt.Errorf("GameID this(%v) Not Equal that(%v)", this.GameID, that1.GameID)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *CloseGameRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloseGameRequest)
	if !ok {
		that2, ok := that.(CloseGameRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GameID != that1.GameID {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CloseGameResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CloseGameResponse)
	if !ok {
		that2, ok := that.(CloseGameResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *CloseGameResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CloseGameResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CloseGameResponse but is not nil && this == nil")
	}
	if this.Success != that1.Success {
		return fmt.Errorf("Success this(%v) Not Equal that(%v)", this.Success, that1.Success)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *CloseGameResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloseGameResponse)
	if !ok {
		that2, ok := that.(CloseGameResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FindGameRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FindGameRequest)
	if !ok {
		that2, ok := that.(FindGameRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FindGameRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FindGameRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FindGameRequest but is not nil && this == nil")
	}
	if this.GameID != that1.GameID {
		return fmt.Errorf("GameID this(%v) Not Equal that(%v)", this.GameID, that1.GameID)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *FindGameRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FindGameRequest)
	if !ok {
		that2, ok := that.(FindGameRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GameID != that1.GameID {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FindGameResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FindGameResponse)
	if !ok {
		that2, ok := that.(FindGameResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FindGameResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FindGameResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FindGameResponse but is not nil && this == nil")
	}
	if !this.Game.Equal(that1.Game) {
		return fmt.Errorf("Game this(%v) Not Equal that(%v)", this.Game, that1.Game)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *FindGameResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FindGameResponse)
	if !ok {
		that2, ok := that.(FindGameResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Game.Equal(that1.Game) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FindGamesRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FindGamesRequest)
	if !ok {
		that2, ok := that.(FindGamesRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FindGamesRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FindGamesRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FindGamesRequest but is not nil && this == nil")
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *FindGamesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FindGamesRequest)
	if !ok {
		that2, ok := that.(FindGamesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *FindGamesResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*FindGamesResponse)
	if !ok {
		that2, ok := that.(FindGamesResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *FindGamesResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *FindGamesResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *FindGamesResponse but is not nil && this == nil")
	}
	if len(this.Games) != len(that1.Games) {
		return fmt.Errorf("Games this(%v) Not Equal that(%v)", len(this.Games), len(that1.Games))
	}
	for i := range this.Games {
		if !this.Games[i].Equal(that1.Games[i]) {
			return fmt.Errorf("Games this[%v](%v) Not Equal that[%v](%v)", i, this.Games[i], i, that1.Games[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *FindGamesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FindGamesResponse)
	if !ok {
		that2, ok := that.(FindGamesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Games) != len(that1.Games) {
		return false
	}
	for i := range this.Games {
		if !this.Games[i].Equal(that1.Games[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (m *AddGameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddGameRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddGameRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.GameID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Runmode) > 0 {
		i -= len(m.Runmode)
		copy(dAtA[i:], m.Runmode)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Runmode)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MaxPeople != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxPeople))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddGameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddGameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddGameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StartGameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartGameRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartGameRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Memory != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x40
	}
	if m.Cpu != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Cpu))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Commonds) > 0 {
		for iNdEx := len(m.Commonds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Commonds[iNdEx])
			copy(dAtA[i:], m.Commonds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Commonds[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Port != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x20
	}
	if m.Replicas != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Replicas))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x12
	}
	if m.GameID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StartGameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartGameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartGameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CloseGameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseGameRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseGameRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CloseGameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseGameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseGameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FindGameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindGameRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindGameRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GameID != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FindGameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindGameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindGameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Game != nil {
		{
			size, err := m.Game.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FindGamesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindGamesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindGamesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *FindGamesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindGamesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindGamesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Games) > 0 {
		for iNdEx := len(m.Games) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Games[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AddGameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovTypes(uint64(m.GameID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxPeople != 0 {
		n += 1 + sovTypes(uint64(m.MaxPeople))
	}
	l = len(m.Runmode)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddGameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartGameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovTypes(uint64(m.GameID))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Replicas != 0 {
		n += 1 + sovTypes(uint64(m.Replicas))
	}
	if m.Port != 0 {
		n += 1 + sovTypes(uint64(m.Port))
	}
	if len(m.Commonds) > 0 {
		for _, s := range m.Commonds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Cpu != 0 {
		n += 1 + sovTypes(uint64(m.Cpu))
	}
	if m.Memory != 0 {
		n += 1 + sovTypes(uint64(m.Memory))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartGameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloseGameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovTypes(uint64(m.GameID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloseGameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindGameRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GameID != 0 {
		n += 1 + sovTypes(uint64(m.GameID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindGameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Game != nil {
		l = m.Game.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindGamesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindGamesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Games) > 0 {
		for _, e := range m.Games {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddGameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddGameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddGameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &GameConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPeople", wireType)
			}
			m.MaxPeople = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPeople |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runmode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runmode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddGameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddGameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddGameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartGameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartGameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartGameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			m.Replicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Replicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commonds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commonds = append(m.Commonds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			m.Cpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartGameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartGameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartGameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseGameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseGameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseGameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseGameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseGameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseGameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindGameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindGameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindGameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindGameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindGameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindGameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Game", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Game == nil {
				m.Game = &game.Game{}
			}
			if err := m.Game.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindGamesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindGamesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindGamesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindGamesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindGamesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindGamesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Games", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Games = append(m.Games, &game.Game{})
			if err := m.Games[len(m.Games)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
