// code generated by github.com/kubegames/protoc-gen-gin. DO NOT EDIT.

package game

//GameService
//game_service.GameService
//// hall game api service

import (
	"context"
	"fmt"
	"github.com/gin-gonic/gin"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	types "github.com/kubegames/kubegames-hall/app/service/game/types"
)

func NewGameServiceError(code int, format string, a ...interface{}) error {
	return status.Error(codes.Code(code), fmt.Sprintf(format, a...))
}

type GameServiceHTTPServer interface {
	AddGameRequest(ctx context.Context, request *types.AddGameRequest) (response *types.AddGameResponse, err error)

	CloseGame(ctx context.Context, request *types.CloseGameRequest) (response *types.CloseGameResponse, err error)

	FindGame(ctx context.Context, request *types.FindGameRequest) (response *types.FindGameResponse, err error)

	FindGames(ctx context.Context, request *types.FindGamesRequest) (response *types.FindGamesResponse, err error)

	StartGame(ctx context.Context, request *types.StartGameRequest) (response *types.StartGameResponse, err error)
}

func RegisterGameServiceHTTPServer(r gin.IRouter, srv GameServiceHTTPServer) {
	//init router
	s := _GameService{
		server: srv,
		router: r,
	}
	s._RegisterService()
}

type _GameService struct {
	server GameServiceHTTPServer
	router gin.IRouter
}

func (s *_GameService) AddGameRequest_0(ctx *gin.Context) {
	var in types.AddGameRequest

	if err := ctx.ShouldBindJSON(&in); err != nil {
		_GameServiceParamsError(ctx, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.server.(GameServiceHTTPServer).AddGameRequest(newCtx, &in)
	if err != nil {
		_GameServiceError(ctx, err)
		return
	}

	_GameServiceSuccess(ctx, out)
}

func (s *_GameService) StartGame_0(ctx *gin.Context) {
	var in types.StartGameRequest

	if err := ctx.ShouldBindJSON(&in); err != nil {
		_GameServiceParamsError(ctx, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.server.(GameServiceHTTPServer).StartGame(newCtx, &in)
	if err != nil {
		_GameServiceError(ctx, err)
		return
	}

	_GameServiceSuccess(ctx, out)
}

func (s *_GameService) CloseGame_0(ctx *gin.Context) {
	var in types.CloseGameRequest

	if err := ctx.ShouldBindUri(&in); err != nil {
		_GameServiceParamsError(ctx, err)
		return
	}

	if err := ctx.ShouldBindQuery(&in); err != nil {
		_GameServiceParamsError(ctx, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.server.(GameServiceHTTPServer).CloseGame(newCtx, &in)
	if err != nil {
		_GameServiceError(ctx, err)
		return
	}

	_GameServiceSuccess(ctx, out)
}

func (s *_GameService) FindGame_0(ctx *gin.Context) {
	var in types.FindGameRequest

	if err := ctx.ShouldBindUri(&in); err != nil {
		_GameServiceParamsError(ctx, err)
		return
	}

	if err := ctx.ShouldBindQuery(&in); err != nil {
		_GameServiceParamsError(ctx, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.server.(GameServiceHTTPServer).FindGame(newCtx, &in)
	if err != nil {
		_GameServiceError(ctx, err)
		return
	}

	_GameServiceSuccess(ctx, out)
}

func (s *_GameService) FindGames_0(ctx *gin.Context) {
	var in types.FindGamesRequest

	if err := ctx.ShouldBindQuery(&in); err != nil {
		_GameServiceParamsError(ctx, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.server.(GameServiceHTTPServer).FindGames(newCtx, &in)
	if err != nil {
		_GameServiceError(ctx, err)
		return
	}

	_GameServiceSuccess(ctx, out)
}

func (s *_GameService) _RegisterService() {

	s.router.Handle("POST", "/game/v1/add", s.AddGameRequest_0)

	s.router.Handle("POST", "/game/v1/start", s.StartGame_0)

	s.router.Handle("DELETE", "/game/v1/close/:gameID", s.CloseGame_0)

	s.router.Handle("GET", "/game/v1/find/:gameID", s.FindGame_0)

	s.router.Handle("GET", "/game/v1/finds", s.FindGames_0)

}

func _GameServiceError(ctx *gin.Context, err error) {
	code := 500

	msg := "unknow error"
	if err == nil {
		msg += ", err is nil"
		ctx.JSON(code, map[string]interface{}{
			"code": code,
			"msg":  msg,
			"data": nil,
		})
		return
	}

	if c, ok := status.FromError(err); ok {
		code = int(c.Code())
		msg = c.Message()
	}

	//_ = ctx.Error(err)

	ctx.JSON(code, map[string]interface{}{
		"code": code,
		"msg":  msg,
		"data": nil,
	})
}

func _GameServiceParamsError(ctx *gin.Context, err error) {
	ctx.JSON(400, map[string]interface{}{
		"code": 400,
		"msg":  err.Error(),
		"data": nil,
	})
}

func _GameServiceSuccess(ctx *gin.Context, data interface{}) {
	ctx.JSON(200, map[string]interface{}{
		"code": 200,
		"msg":  "success",
		"data": data,
	})
}
