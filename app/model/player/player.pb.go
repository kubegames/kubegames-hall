// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/model/player/player.proto

package player

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	github_com_kubegames_protobuf_types "github.com/kubegames/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PlayerBill_BillKind int32

const (
	//全部
	PlayerBill_All PlayerBill_BillKind = 0
	//充值
	PlayerBill_Recharge PlayerBill_BillKind = 1
	//赠送
	PlayerBill_Give PlayerBill_BillKind = 2
	//游戏
	PlayerBill_Game PlayerBill_BillKind = 3
)

var PlayerBill_BillKind_name = map[int32]string{
	0: "All",
	1: "Recharge",
	2: "Give",
	3: "Game",
}

var PlayerBill_BillKind_value = map[string]int32{
	"All":      0,
	"Recharge": 1,
	"Give":     2,
	"Game":     3,
}

func (x PlayerBill_BillKind) String() string {
	return proto.EnumName(PlayerBill_BillKind_name, int32(x))
}

func (PlayerBill_BillKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21b755845381273d, []int{3, 0}
}

//玩家基础信息
type Player struct {
	//玩家 id
	PlayerID uint32 `protobuf:"varint,1,opt,name=playerID,proto3" json:"playerID,omitempty" xorm:"not null pk autoincr comment('player id') BigInt"`
	//电话
	Phone string `protobuf:"bytes,2,opt,name=phone,proto3" json:"phone,omitempty" xorm:"unique comment('player phone') Varchar(13)"`
	//密码
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty" xorm:"unique comment('player password') Varchar(255)"`
	//用户金币
	Balance int64 `protobuf:"varint,4,opt,name=balance,proto3" json:"balance,omitempty" xorm:"comment('player balance') BigInt"`
	//玩家打码量
	Chip int64 `protobuf:"varint,5,opt,name=chip,proto3" json:"chip,omitempty" xorm:"comment('player chip') BigInt"`
	//用户头像
	Avatar string `protobuf:"bytes,6,opt,name=avatar,proto3" json:"avatar,omitempty" xorm:"comment('player avatar') Varchar(2083)"`
	//用户昵称
	Nick string `protobuf:"bytes,7,opt,name=nick,proto3" json:"nick,omitempty" xorm:"comment('player nick') Varchar(255)"`
	//账号
	Account string `protobuf:"bytes,8,opt,name=account,proto3" json:"account,omitempty" xorm:"unique comment('player account') Varchar(13)"`
	//设备码
	EquipmentCode string `protobuf:"bytes,9,opt,name=equipmentCode,proto3" json:"equipmentCode,omitempty" xorm:"comment('player equipmentCode') Varchar(255)"`
	//业主id
	PlatformID uint32 `protobuf:"varint,10,opt,name=platformID,proto3" json:"platformID,omitempty" xorm:"comment('player platform id') BigInt"`
	//性别
	Sex int32 `protobuf:"varint,11,opt,name=sex,proto3" json:"sex,omitempty" xorm:"comment('player sex') Int"`
	//城市
	City string `protobuf:"bytes,12,opt,name=city,proto3" json:"city,omitempty" xorm:"comment('player city') Varchar(125)"`
	//IP
	Ip string `protobuf:"bytes,13,opt,name=ip,proto3" json:"ip,omitempty" xorm:"comment('player ip') Varchar(125)"`
	//签名
	Sign string `protobuf:"bytes,14,opt,name=sign,proto3" json:"sign,omitempty" xorm:"comment('player sign') Varchar(255)"`
	//是否机器人
	IsRobot bool `protobuf:"varint,15,opt,name=isRobot,proto3" json:"isRobot,omitempty" xorm:"comment('player is robot') Bool"`
	//点控概率
	Pointctl int32 `protobuf:"varint,16,opt,name=pointctl,proto3" json:"pointctl,omitempty" xorm:"comment('player pointctl') BigInt"`
	//血池
	Roomctl int32 `protobuf:"varint,17,opt,name=roomctl,proto3" json:"roomctl,omitempty" xorm:"comment('player roomctl') BigInt"`
	//更新时间
	UpdatedAt time.Time `protobuf:"bytes,18,opt,name=updatedAt,proto3,stdtime" json:"updatedAt" xorm:"updated"`
	//创建时间
	CreatedAt time.Time `protobuf:"bytes,19,opt,name=createdAt,proto3,stdtime" json:"createdAt" xorm:"created"`
	// 版本
	Version              int32    `protobuf:"varint,20,opt,name=version,proto3" json:"version,omitempty" xorm:"version"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_21b755845381273d, []int{0}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

//玩家状态
type Status struct {
	//玩家 id
	PlayerID uint32 `protobuf:"varint,1,opt,name=playerID,proto3" json:"playerID,omitempty" xorm:"not null pk comment('player id') BigInt"`
	//game id
	GameID uint32 `protobuf:"varint,2,opt,name=gameID,proto3" json:"gameID,omitempty" xorm:"comment('game id') BigInt"`
	//room id
	RoomID uint32 `protobuf:"varint,3,opt,name=roomID,proto3" json:"roomID,omitempty" xorm:"comment('room id') BigInt"`
	//game server pod name
	PodName string `protobuf:"bytes,4,opt,name=podName,proto3" json:"podName,omitempty" xorm:"comment('pod name') Varchar(255)"`
	//游戏服务地址
	Ip string `protobuf:"bytes,5,opt,name=ip,proto3" json:"ip,omitempty" xorm:"comment('游戏服务地址') Varchar(255)"`
	//token
	Token string `protobuf:"bytes,6,opt,name=token,proto3" json:"token,omitempty" xorm:"comment('token') Text"`
	//更新时间
	UpdatedAt time.Time `protobuf:"bytes,7,opt,name=updatedAt,proto3,stdtime" json:"updatedAt" xorm:"updated"`
	//创建时间
	CreatedAt time.Time `protobuf:"bytes,8,opt,name=createdAt,proto3,stdtime" json:"createdAt" xorm:"created"`
	// 版本
	Version              int32    `protobuf:"varint,9,opt,name=version,proto3" json:"version,omitempty" xorm:"version"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_21b755845381273d, []int{1}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

//玩家战绩
type PlayerRecord struct {
	//自增ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" xorm:"not null pk autoincr comment('room id') BigInt"`
	//玩家 id
	PlayerID uint32 `protobuf:"varint,2,opt,name=playerID,proto3" json:"playerID,omitempty" xorm:"index comment('player id') BigInt"`
	//局号
	GameNum string `protobuf:"bytes,3,opt,name=gameNum,proto3" json:"gameNum,omitempty" xorm:"comment('局号') Varchar(255)"`
	//盈利
	ProfitAmount int64 `protobuf:"varint,4,opt,name=profitAmount,proto3" json:"profitAmount,omitempty" xorm:"comment('盈利') BigInt"`
	//总下注
	BetsAmount int64 `protobuf:"varint,5,opt,name=betsAmount,proto3" json:"betsAmount,omitempty" xorm:"comment('总下注') BigInt"`
	//总抽水
	DrawAmount int64 `protobuf:"varint,6,opt,name=drawAmount,proto3" json:"drawAmount,omitempty" xorm:"comment('总抽水') BigInt"`
	//总产出
	OutputAmount int64 `protobuf:"varint,7,opt,name=outputAmount,proto3" json:"outputAmount,omitempty" xorm:"comment('总产出') BigInt"`
	//房间ID
	RoomID uint32 `protobuf:"varint,8,opt,name=roomID,proto3" json:"roomID,omitempty" xorm:"index comment('房间ID') BigInt"`
	//游戏ID
	GameID uint32 `protobuf:"varint,9,opt,name=gameID,proto3" json:"gameID,omitempty" xorm:"index comment('游戏ID') BigInt"`
	//用户当前金币
	Balance int64 `protobuf:"varint,10,opt,name=balance,proto3" json:"balance,omitempty" xorm:"comment('player balance') BigInt"`
	//更新时间
	UpdatedAt time.Time `protobuf:"bytes,11,opt,name=updatedAt,proto3,stdtime" json:"updatedAt" xorm:"updated"`
	//创建时间
	CreatedAt            time.Time `protobuf:"bytes,12,opt,name=createdAt,proto3,stdtime" json:"createdAt" xorm:"created"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte    `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32     `json:"-" xorm:"-" gorm:"-"`
}

func (m *PlayerRecord) Reset()         { *m = PlayerRecord{} }
func (m *PlayerRecord) String() string { return proto.CompactTextString(m) }
func (*PlayerRecord) ProtoMessage()    {}
func (*PlayerRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_21b755845381273d, []int{2}
}
func (m *PlayerRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerRecord.Merge(m, src)
}
func (m *PlayerRecord) XXX_Size() int {
	return m.Size()
}
func (m *PlayerRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerRecord.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerRecord proto.InternalMessageInfo

//玩家账单
type PlayerBill struct {
	//自增ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" xorm:"not null pk autoincr comment('room id') BigInt"`
	//玩家 id
	PlayerID uint32 `protobuf:"varint,2,opt,name=playerID,proto3" json:"playerID,omitempty" xorm:"index comment('player id') BigInt"`
	//变动前
	Before int64 `protobuf:"varint,3,opt,name=before,proto3" json:"before,omitempty" xorm:"comment('player id') BigInt"`
	//变动的钱
	Balance int64 `protobuf:"varint,4,opt,name=balance,proto3" json:"balance,omitempty" xorm:"comment('player id') BigInt"`
	//变动后
	After int64 `protobuf:"varint,5,opt,name=after,proto3" json:"after,omitempty" xorm:"comment('player id') BigInt"`
	//类型0 全部 1充值 2赠送 3游戏变动
	Kind PlayerBill_BillKind `protobuf:"varint,6,opt,name=kind,proto3,enum=model_player.PlayerBill_BillKind" json:"kind,omitempty" xorm:"comment('bill kind') BigInt"`
	//更新时间
	UpdatedAt time.Time `protobuf:"bytes,7,opt,name=updatedAt,proto3,stdtime" json:"updatedAt" xorm:"updated"`
	//创建时间
	CreatedAt            time.Time `protobuf:"bytes,8,opt,name=createdAt,proto3,stdtime" json:"createdAt" xorm:"created"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte    `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32     `json:"-" xorm:"-" gorm:"-"`
}

func (m *PlayerBill) Reset()         { *m = PlayerBill{} }
func (m *PlayerBill) String() string { return proto.CompactTextString(m) }
func (*PlayerBill) ProtoMessage()    {}
func (*PlayerBill) Descriptor() ([]byte, []int) {
	return fileDescriptor_21b755845381273d, []int{3}
}
func (m *PlayerBill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerBill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerBill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerBill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerBill.Merge(m, src)
}
func (m *PlayerBill) XXX_Size() int {
	return m.Size()
}
func (m *PlayerBill) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerBill.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerBill proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("model_player.PlayerBill_BillKind", PlayerBill_BillKind_name, PlayerBill_BillKind_value)
	proto.RegisterType((*Player)(nil), "model_player.Player")
	proto.RegisterType((*Status)(nil), "model_player.Status")
	proto.RegisterType((*PlayerRecord)(nil), "model_player.PlayerRecord")
	proto.RegisterType((*PlayerBill)(nil), "model_player.PlayerBill")
}

func init() { proto.RegisterFile("app/model/player/player.proto", fileDescriptor_21b755845381273d) }

var fileDescriptor_21b755845381273d = []byte{
	// 1296 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x97, 0x4d, 0x6f, 0xdc, 0x44,
	0x18, 0xc7, 0xe3, 0x64, 0xdf, 0x32, 0xd9, 0x94, 0x30, 0x70, 0xb0, 0x22, 0x58, 0x1b, 0x53, 0xba,
	0xbb, 0x7d, 0xd9, 0xa5, 0x29, 0x69, 0x79, 0xa9, 0x10, 0xdd, 0xa4, 0x94, 0xa5, 0x52, 0x81, 0xa5,
	0x80, 0x84, 0x54, 0x21, 0xaf, 0x3d, 0xd9, 0x8c, 0x62, 0x7b, 0x5c, 0x7b, 0xdc, 0xa6, 0xb7, 0xde,
	0x88, 0x8a, 0x50, 0xb9, 0x81, 0x44, 0x39, 0x20, 0x0e, 0x94, 0x5b, 0x11, 0x95, 0xa8, 0x8a, 0x10,
	0xd7, 0x4a, 0x5c, 0xf8, 0x04, 0xa6, 0x0d, 0xec, 0x22, 0xae, 0x16, 0x1f, 0x00, 0xcd, 0xd8, 0xce,
	0x7a, 0xbd, 0x66, 0x53, 0x04, 0x95, 0xe0, 0x92, 0xac, 0xc7, 0xff, 0xff, 0x4f, 0x33, 0xcf, 0x3c,
	0xcf, 0x33, 0x63, 0xf0, 0xb8, 0x6a, 0xdb, 0x4d, 0x93, 0xe8, 0xc8, 0x68, 0xda, 0x86, 0x7a, 0x09,
	0x39, 0xd1, 0xbf, 0x86, 0xed, 0x10, 0x4a, 0x60, 0x99, 0xbf, 0x7a, 0x2f, 0x1c, 0x5b, 0x94, 0x99,
	0xd8, 0xc0, 0xdd, 0x66, 0x8f, 0xf4, 0x48, 0x93, 0x2b, 0xba, 0xde, 0x1a, 0x7f, 0x0a, 0xf5, 0x8b,
	0xd5, 0xa1, 0x82, 0xf4, 0x0c, 0x34, 0xd4, 0x50, 0x6c, 0x22, 0x97, 0xaa, 0xa6, 0x1d, 0x0a, 0x95,
	0x1f, 0xe7, 0x40, 0xe1, 0x75, 0x4e, 0x85, 0xef, 0x80, 0x52, 0xc8, 0x6f, 0xaf, 0x8a, 0x82, 0x2c,
	0xd4, 0xe6, 0x5b, 0x2f, 0x04, 0xbe, 0x74, 0x6c, 0x93, 0x38, 0xe6, 0xf3, 0x8a, 0x45, 0xa8, 0x6c,
	0x79, 0x86, 0x21, 0xdb, 0x1b, 0xb2, 0xea, 0x51, 0x82, 0x2d, 0xcd, 0x91, 0x35, 0x62, 0x9a, 0xc8,
	0xa2, 0xb5, 0x6a, 0xe8, 0x93, 0xb1, 0x5e, 0xad, 0xcb, 0x2d, 0xdc, 0x6b, 0x5b, 0x54, 0xe9, 0xec,
	0xc0, 0xe0, 0x69, 0x90, 0xb7, 0xd7, 0x89, 0x85, 0xc4, 0x69, 0x59, 0xa8, 0xcd, 0xb6, 0x96, 0x03,
	0x5f, 0x3a, 0x1c, 0x52, 0x3d, 0x0b, 0x9f, 0xf7, 0xd0, 0x18, 0x87, 0xab, 0xab, 0x75, 0xf9, 0x6d,
	0xd5, 0xd1, 0xd6, 0x55, 0xa7, 0x76, 0xf8, 0x48, 0x5d, 0xe9, 0x84, 0x0c, 0xf8, 0x16, 0x28, 0xd9,
	0xaa, 0xeb, 0x5e, 0x24, 0x8e, 0x2e, 0xce, 0x70, 0xde, 0x73, 0x81, 0x2f, 0x2d, 0x4f, 0xe6, 0x45,
	0x86, 0x04, 0x72, 0x69, 0x79, 0xb9, 0xce, 0xe6, 0x18, 0xbd, 0x81, 0x27, 0x41, 0xb1, 0xab, 0x1a,
	0xaa, 0xa5, 0x21, 0x31, 0x27, 0x0b, 0xb5, 0x99, 0xd6, 0x81, 0xc0, 0x97, 0xaa, 0x21, 0x35, 0x8d,
	0x8b, 0x84, 0x89, 0xb5, 0xc6, 0x5e, 0x78, 0x1c, 0xe4, 0xb4, 0x75, 0x6c, 0x8b, 0x79, 0xce, 0xa8,
	0x05, 0xbe, 0xb4, 0x37, 0x9b, 0xc1, 0x54, 0x09, 0x00, 0x77, 0xc1, 0x36, 0x28, 0xa8, 0x17, 0x54,
	0xaa, 0x3a, 0x62, 0x81, 0xaf, 0xec, 0x70, 0xe0, 0x4b, 0x87, 0xb2, 0xfd, 0xa1, 0x2e, 0xb9, 0xa0,
	0xa7, 0x9f, 0x65, 0x51, 0x8a, 0x00, 0xb0, 0x05, 0x72, 0x16, 0xd6, 0x36, 0xc4, 0x22, 0x07, 0x35,
	0x02, 0x5f, 0xda, 0x9f, 0x0d, 0x62, 0xaa, 0xb1, 0xb8, 0x70, 0x2f, 0x7c, 0x03, 0x14, 0x55, 0x4d,
	0x23, 0x9e, 0x45, 0xc5, 0x12, 0xc7, 0x1c, 0x0b, 0x7c, 0xe9, 0xc8, 0xc4, 0x48, 0x47, 0xfa, 0xf4,
	0xde, 0xc5, 0x1c, 0x78, 0x0e, 0xcc, 0xa3, 0xf3, 0x1e, 0xb6, 0x99, 0x69, 0x85, 0xe8, 0x48, 0x9c,
	0x4d, 0x83, 0xd3, 0xc4, 0x11, 0xf9, 0xd8, 0x44, 0x47, 0x69, 0xf0, 0x35, 0x00, 0x6c, 0x43, 0xa5,
	0x6b, 0xc4, 0x31, 0xdb, 0xab, 0x22, 0xe0, 0x49, 0xdc, 0x0c, 0x7c, 0xe9, 0x40, 0x36, 0x3b, 0xd6,
	0x8e, 0x26, 0x6e, 0x02, 0x01, 0x8f, 0x82, 0x19, 0x17, 0x6d, 0x8a, 0x73, 0xb2, 0x50, 0xcb, 0xb7,
	0xf6, 0x06, 0xbe, 0x24, 0x67, 0x93, 0x5c, 0xb4, 0x59, 0xad, 0xcb, 0xdc, 0xce, 0x0c, 0x2c, 0xfc,
	0x1a, 0xa6, 0x97, 0xc4, 0xf2, 0x6e, 0xe1, 0x67, 0xaa, 0x64, 0xb4, 0x96, 0x78, 0xf8, 0xd9, 0x28,
	0x3c, 0x0e, 0xa6, 0xb1, 0x2d, 0xce, 0x73, 0xc2, 0xc1, 0xc0, 0x97, 0x6a, 0xd9, 0x04, 0x9e, 0x47,
	0xa3, 0xfe, 0x69, 0x6c, 0xb3, 0x19, 0xb8, 0xb8, 0x67, 0x89, 0x7b, 0x76, 0x9b, 0x01, 0x53, 0x8d,
	0x27, 0x00, 0x1b, 0x85, 0xab, 0xa0, 0x88, 0xdd, 0x0e, 0xe9, 0x12, 0x2a, 0x3e, 0x24, 0x0b, 0xb5,
	0x52, 0x6b, 0x7f, 0xe0, 0x4b, 0xfb, 0xfe, 0x62, 0x1a, 0xae, 0xec, 0x30, 0x25, 0x0b, 0x24, 0x21,
	0x86, 0xd2, 0x89, 0xad, 0xf0, 0x15, 0x50, 0xb2, 0x09, 0xb6, 0xa8, 0x46, 0x0d, 0x71, 0x81, 0x07,
	0x72, 0xc2, 0x6a, 0x62, 0xe5, 0x48, 0x23, 0x89, 0xc6, 0x58, 0x91, 0x3a, 0x84, 0x98, 0x0c, 0xf4,
	0x30, 0x07, 0x4d, 0x28, 0xd2, 0x48, 0x98, 0x2c, 0xd2, 0x68, 0x08, 0x9e, 0x05, 0xb3, 0x9e, 0xad,
	0xab, 0x14, 0xe9, 0x27, 0xa8, 0x08, 0x65, 0xa1, 0x36, 0xb7, 0xb4, 0xd8, 0x08, 0x1b, 0x65, 0x23,
	0x6e, 0x94, 0x8d, 0xb3, 0x71, 0xa3, 0x6c, 0x2d, 0xde, 0xf1, 0xa5, 0xa9, 0xc0, 0x97, 0xf6, 0x44,
	0x99, 0x1f, 0x5a, 0x95, 0x8f, 0x7e, 0x96, 0x84, 0xce, 0x10, 0xc4, 0xa8, 0x9a, 0x83, 0x22, 0xea,
	0x23, 0x7f, 0x97, 0x1a, 0x59, 0x23, 0xea, 0x0e, 0x08, 0x1e, 0x04, 0xc5, 0x0b, 0xc8, 0x71, 0x31,
	0xb1, 0xc4, 0x47, 0xf9, 0x92, 0xe1, 0xd0, 0x13, 0xbd, 0x50, 0x3a, 0xb1, 0x44, 0xf9, 0x23, 0x07,
	0x0a, 0x6f, 0x52, 0x95, 0x7a, 0x2e, 0x3c, 0x33, 0xd6, 0xcd, 0x97, 0x02, 0x5f, 0x6a, 0x8c, 0x77,
	0xf3, 0xfb, 0x6c, 0xe2, 0xc7, 0x41, 0xa1, 0xa7, 0x9a, 0xa8, 0xbd, 0xca, 0xbb, 0xf8, 0x7c, 0x66,
	0x31, 0x30, 0xc1, 0xa8, 0x3f, 0xf2, 0x30, 0x37, 0x8b, 0x7e, 0x7b, 0x95, 0xf7, 0xec, 0x6c, 0x37,
	0x13, 0xa4, 0xdc, 0xa1, 0x87, 0xed, 0xbb, 0x4d, 0xf4, 0x33, 0xaa, 0x19, 0x36, 0xe7, 0xd9, 0xec,
	0x7d, 0x27, 0xba, 0x6c, 0xa9, 0xe6, 0x78, 0x8f, 0x88, 0xbd, 0xf0, 0x24, 0x2f, 0xa8, 0x7c, 0xfa,
	0x10, 0xda, 0x21, 0x0c, 0x6e, 0xdd, 0x1a, 0x6c, 0x5d, 0x1d, 0x5c, 0xfb, 0xb0, 0x7f, 0xe5, 0xf3,
	0xfe, 0xb5, 0x1b, 0xfd, 0xcf, 0x2e, 0x8f, 0xb1, 0x58, 0x65, 0x1d, 0x05, 0x79, 0x4a, 0x36, 0x90,
	0x15, 0x35, 0x69, 0x39, 0xf0, 0xa5, 0xc7, 0x52, 0x24, 0xfe, 0xbe, 0x5a, 0x97, 0xcf, 0xa2, 0x4d,
	0xaa, 0x74, 0x42, 0xf9, 0x68, 0xda, 0x15, 0x1f, 0x48, 0xda, 0x95, 0x1e, 0x40, 0xda, 0xcd, 0xee,
	0x9e, 0x76, 0x57, 0x8a, 0xa0, 0x1c, 0x5e, 0x22, 0x3a, 0x48, 0x63, 0xa7, 0x69, 0x1b, 0x4c, 0x63,
	0x9d, 0xa7, 0x5d, 0x2e, 0x79, 0x3c, 0x4f, 0xbe, 0x44, 0x8c, 0xef, 0xff, 0x34, 0xd6, 0x79, 0xf7,
	0x88, 0xf3, 0x38, 0xcc, 0xbc, 0x44, 0xf7, 0xc0, 0x96, 0x8e, 0x36, 0xef, 0x37, 0x83, 0x57, 0x40,
	0x91, 0x65, 0xe3, 0x19, 0xcf, 0x8c, 0x2e, 0x0e, 0xf5, 0xc0, 0x97, 0x9e, 0x4a, 0xed, 0x5c, 0xff,
	0xeb, 0xcb, 0xfd, 0xab, 0xdf, 0x8e, 0xe7, 0x50, 0xe4, 0x84, 0xa7, 0x40, 0xd9, 0x76, 0xc8, 0x1a,
	0xa6, 0x27, 0x4c, 0x7e, 0x30, 0x86, 0x97, 0x85, 0x27, 0x03, 0x5f, 0x92, 0x52, 0xa4, 0xdf, 0x3e,
	0xdd, 0xea, 0x6f, 0x7d, 0x95, 0x98, 0xc9, 0x88, 0x11, 0xbe, 0x0c, 0x40, 0x17, 0x51, 0x37, 0xc2,
	0x84, 0xf7, 0x85, 0x7d, 0x81, 0x2f, 0x29, 0xe9, 0xa4, 0xbc, 0xfc, 0xdd, 0xaf, 0xb7, 0x3e, 0x18,
	0x7c, 0x73, 0x3d, 0x79, 0x42, 0x0d, 0x9d, 0x8c, 0xa3, 0x3b, 0xea, 0xc5, 0x88, 0x53, 0x98, 0xc4,
	0x19, 0x5c, 0xf9, 0x7e, 0x70, 0xe3, 0x66, 0x92, 0x33, 0x74, 0xc2, 0x57, 0x41, 0x99, 0x78, 0xd4,
	0xf6, 0xe2, 0x85, 0x15, 0x27, 0xce, 0xe8, 0xf6, 0x97, 0xfd, 0xf7, 0x6f, 0x27, 0xd7, 0x96, 0xf4,
	0xc2, 0x95, 0x9d, 0x6a, 0x2f, 0xf1, 0x1d, 0x4b, 0x94, 0x6b, 0x6a, 0xc7, 0x06, 0x5b, 0x3f, 0xfc,
	0xfe, 0xf1, 0xcd, 0xf6, 0x6a, 0x46, 0xd1, 0xaf, 0xec, 0x34, 0x9c, 0xd9, 0xdd, 0x20, 0xbc, 0x6e,
	0x47, 0x21, 0x51, 0xdf, 0x49, 0x5c, 0xeb, 0xc0, 0x3f, 0xb8, 0xd6, 0x8d, 0x94, 0xee, 0xdc, 0x03,
	0x29, 0xdd, 0xf2, 0xbf, 0x54, 0xba, 0xca, 0x17, 0x79, 0x00, 0xc2, 0x62, 0x6c, 0x61, 0xc3, 0xf8,
	0x6f, 0x96, 0xe2, 0x8b, 0xa0, 0xd0, 0x45, 0x6b, 0xc4, 0x41, 0xbc, 0x12, 0xb3, 0xd3, 0x2c, 0x8b,
	0x10, 0xb9, 0xe0, 0x4b, 0xe9, 0xdb, 0xfa, 0xfd, 0x02, 0x12, 0x17, 0xf5, 0xbc, 0xba, 0x46, 0x91,
	0x33, 0xa1, 0xf2, 0xb2, 0xfc, 0xa1, 0x09, 0x9e, 0x03, 0xb9, 0x0d, 0x6c, 0xe9, 0xbc, 0xdc, 0xf6,
	0x2c, 0x3d, 0xd1, 0x48, 0x7e, 0x9d, 0x35, 0x86, 0xc1, 0x6f, 0xb0, 0x3f, 0xa7, 0xb1, 0xa5, 0x67,
	0xf2, 0xbb, 0xd8, 0x30, 0x64, 0x86, 0x49, 0x7e, 0x07, 0xb0, 0xe7, 0xff, 0xd3, 0x49, 0xa1, 0x2c,
	0x83, 0x52, 0xbc, 0x4a, 0x58, 0x04, 0x33, 0x27, 0x0c, 0x63, 0x61, 0x0a, 0x96, 0x41, 0xa9, 0x83,
	0x58, 0xfb, 0xec, 0xa1, 0x05, 0x01, 0x96, 0x40, 0xee, 0x14, 0xbe, 0x80, 0x16, 0xa6, 0xf9, 0x2f,
	0xd5, 0x44, 0x0b, 0x33, 0xad, 0xce, 0x9d, 0x7b, 0x95, 0xa9, 0xbb, 0xf7, 0x2a, 0xc2, 0xf5, 0xed,
	0x8a, 0x70, 0x67, 0xbb, 0x22, 0xfc, 0xb4, 0x5d, 0x11, 0xee, 0x6e, 0x57, 0x84, 0x4f, 0x7e, 0xa9,
	0x4c, 0xbd, 0xfb, 0x4c, 0x0f, 0xd3, 0x75, 0xaf, 0xdb, 0xd0, 0x88, 0xd9, 0xdc, 0xf0, 0xba, 0x88,
	0x55, 0xb3, 0x3b, 0xfc, 0x75, 0x68, 0x5d, 0x35, 0x8c, 0x66, 0xfa, 0x8b, 0xb9, 0x5b, 0xe0, 0xab,
	0x38, 0xf2, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0x31, 0xdb, 0x58, 0x81, 0x4c, 0x0f, 0x00, 0x00,
}

func (this *Player) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Player)
	if !ok {
		that2, ok := that.(Player)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Player")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Player but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Player but is not nil && this == nil")
	}
	if this.PlayerID != that1.PlayerID {
		return fmt.Errorf("PlayerID this(%v) Not Equal that(%v)", this.PlayerID, that1.PlayerID)
	}
	if this.Phone != that1.Phone {
		return fmt.Errorf("Phone this(%v) Not Equal that(%v)", this.Phone, that1.Phone)
	}
	if this.Password != that1.Password {
		return fmt.Errorf("Password this(%v) Not Equal that(%v)", this.Password, that1.Password)
	}
	if this.Balance != that1.Balance {
		return fmt.Errorf("Balance this(%v) Not Equal that(%v)", this.Balance, that1.Balance)
	}
	if this.Chip != that1.Chip {
		return fmt.Errorf("Chip this(%v) Not Equal that(%v)", this.Chip, that1.Chip)
	}
	if this.Avatar != that1.Avatar {
		return fmt.Errorf("Avatar this(%v) Not Equal that(%v)", this.Avatar, that1.Avatar)
	}
	if this.Nick != that1.Nick {
		return fmt.Errorf("Nick this(%v) Not Equal that(%v)", this.Nick, that1.Nick)
	}
	if this.Account != that1.Account {
		return fmt.Errorf("Account this(%v) Not Equal that(%v)", this.Account, that1.Account)
	}
	if this.EquipmentCode != that1.EquipmentCode {
		return fmt.Errorf("EquipmentCode this(%v) Not Equal that(%v)", this.EquipmentCode, that1.EquipmentCode)
	}
	if this.PlatformID != that1.PlatformID {
		return fmt.Errorf("PlatformID this(%v) Not Equal that(%v)", this.PlatformID, that1.PlatformID)
	}
	if this.Sex != that1.Sex {
		return fmt.Errorf("Sex this(%v) Not Equal that(%v)", this.Sex, that1.Sex)
	}
	if this.City != that1.City {
		return fmt.Errorf("City this(%v) Not Equal that(%v)", this.City, that1.City)
	}
	if this.Ip != that1.Ip {
		return fmt.Errorf("Ip this(%v) Not Equal that(%v)", this.Ip, that1.Ip)
	}
	if this.Sign != that1.Sign {
		return fmt.Errorf("Sign this(%v) Not Equal that(%v)", this.Sign, that1.Sign)
	}
	if this.IsRobot != that1.IsRobot {
		return fmt.Errorf("IsRobot this(%v) Not Equal that(%v)", this.IsRobot, that1.IsRobot)
	}
	if this.Pointctl != that1.Pointctl {
		return fmt.Errorf("Pointctl this(%v) Not Equal that(%v)", this.Pointctl, that1.Pointctl)
	}
	if this.Roomctl != that1.Roomctl {
		return fmt.Errorf("Roomctl this(%v) Not Equal that(%v)", this.Roomctl, that1.Roomctl)
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return fmt.Errorf("UpdatedAt this(%v) Not Equal that(%v)", this.UpdatedAt, that1.UpdatedAt)
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return fmt.Errorf("CreatedAt this(%v) Not Equal that(%v)", this.CreatedAt, that1.CreatedAt)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Player) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Player)
	if !ok {
		that2, ok := that.(Player)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PlayerID != that1.PlayerID {
		return false
	}
	if this.Phone != that1.Phone {
		return false
	}
	if this.Password != that1.Password {
		return false
	}
	if this.Balance != that1.Balance {
		return false
	}
	if this.Chip != that1.Chip {
		return false
	}
	if this.Avatar != that1.Avatar {
		return false
	}
	if this.Nick != that1.Nick {
		return false
	}
	if this.Account != that1.Account {
		return false
	}
	if this.EquipmentCode != that1.EquipmentCode {
		return false
	}
	if this.PlatformID != that1.PlatformID {
		return false
	}
	if this.Sex != that1.Sex {
		return false
	}
	if this.City != that1.City {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	if this.Sign != that1.Sign {
		return false
	}
	if this.IsRobot != that1.IsRobot {
		return false
	}
	if this.Pointctl != that1.Pointctl {
		return false
	}
	if this.Roomctl != that1.Roomctl {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Status) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Status)
	if !ok {
		that2, ok := that.(Status)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Status")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Status but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Status but is not nil && this == nil")
	}
	if this.PlayerID != that1.PlayerID {
		return fmt.Errorf("PlayerID this(%v) Not Equal that(%v)", this.PlayerID, that1.PlayerID)
	}
	if this.GameID != that1.GameID {
		return fmt.Errorf("GameID this(%v) Not Equal that(%v)", this.GameID, that1.GameID)
	}
	if this.RoomID != that1.RoomID {
		return fmt.Errorf("RoomID this(%v) Not Equal that(%v)", this.RoomID, that1.RoomID)
	}
	if this.PodName != that1.PodName {
		return fmt.Errorf("PodName this(%v) Not Equal that(%v)", this.PodName, that1.PodName)
	}
	if this.Ip != that1.Ip {
		return fmt.Errorf("Ip this(%v) Not Equal that(%v)", this.Ip, that1.Ip)
	}
	if this.Token != that1.Token {
		return fmt.Errorf("Token this(%v) Not Equal that(%v)", this.Token, that1.Token)
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return fmt.Errorf("UpdatedAt this(%v) Not Equal that(%v)", this.UpdatedAt, that1.UpdatedAt)
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return fmt.Errorf("CreatedAt this(%v) Not Equal that(%v)", this.CreatedAt, that1.CreatedAt)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Status) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Status)
	if !ok {
		that2, ok := that.(Status)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PlayerID != that1.PlayerID {
		return false
	}
	if this.GameID != that1.GameID {
		return false
	}
	if this.RoomID != that1.RoomID {
		return false
	}
	if this.PodName != that1.PodName {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PlayerRecord) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PlayerRecord)
	if !ok {
		that2, ok := that.(PlayerRecord)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PlayerRecord")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PlayerRecord but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PlayerRecord but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.PlayerID != that1.PlayerID {
		return fmt.Errorf("PlayerID this(%v) Not Equal that(%v)", this.PlayerID, that1.PlayerID)
	}
	if this.GameNum != that1.GameNum {
		return fmt.Errorf("GameNum this(%v) Not Equal that(%v)", this.GameNum, that1.GameNum)
	}
	if this.ProfitAmount != that1.ProfitAmount {
		return fmt.Errorf("ProfitAmount this(%v) Not Equal that(%v)", this.ProfitAmount, that1.ProfitAmount)
	}
	if this.BetsAmount != that1.BetsAmount {
		return fmt.Errorf("BetsAmount this(%v) Not Equal that(%v)", this.BetsAmount, that1.BetsAmount)
	}
	if this.DrawAmount != that1.DrawAmount {
		return fmt.Errorf("DrawAmount this(%v) Not Equal that(%v)", this.DrawAmount, that1.DrawAmount)
	}
	if this.OutputAmount != that1.OutputAmount {
		return fmt.Errorf("OutputAmount this(%v) Not Equal that(%v)", this.OutputAmount, that1.OutputAmount)
	}
	if this.RoomID != that1.RoomID {
		return fmt.Errorf("RoomID this(%v) Not Equal that(%v)", this.RoomID, that1.RoomID)
	}
	if this.GameID != that1.GameID {
		return fmt.Errorf("GameID this(%v) Not Equal that(%v)", this.GameID, that1.GameID)
	}
	if this.Balance != that1.Balance {
		return fmt.Errorf("Balance this(%v) Not Equal that(%v)", this.Balance, that1.Balance)
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return fmt.Errorf("UpdatedAt this(%v) Not Equal that(%v)", this.UpdatedAt, that1.UpdatedAt)
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return fmt.Errorf("CreatedAt this(%v) Not Equal that(%v)", this.CreatedAt, that1.CreatedAt)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *PlayerRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlayerRecord)
	if !ok {
		that2, ok := that.(PlayerRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.PlayerID != that1.PlayerID {
		return false
	}
	if this.GameNum != that1.GameNum {
		return false
	}
	if this.ProfitAmount != that1.ProfitAmount {
		return false
	}
	if this.BetsAmount != that1.BetsAmount {
		return false
	}
	if this.DrawAmount != that1.DrawAmount {
		return false
	}
	if this.OutputAmount != that1.OutputAmount {
		return false
	}
	if this.RoomID != that1.RoomID {
		return false
	}
	if this.GameID != that1.GameID {
		return false
	}
	if this.Balance != that1.Balance {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PlayerBill) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PlayerBill)
	if !ok {
		that2, ok := that.(PlayerBill)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PlayerBill")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PlayerBill but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PlayerBill but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.PlayerID != that1.PlayerID {
		return fmt.Errorf("PlayerID this(%v) Not Equal that(%v)", this.PlayerID, that1.PlayerID)
	}
	if this.Before != that1.Before {
		return fmt.Errorf("Before this(%v) Not Equal that(%v)", this.Before, that1.Before)
	}
	if this.Balance != that1.Balance {
		return fmt.Errorf("Balance this(%v) Not Equal that(%v)", this.Balance, that1.Balance)
	}
	if this.After != that1.After {
		return fmt.Errorf("After this(%v) Not Equal that(%v)", this.After, that1.After)
	}
	if this.Kind != that1.Kind {
		return fmt.Errorf("Kind this(%v) Not Equal that(%v)", this.Kind, that1.Kind)
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return fmt.Errorf("UpdatedAt this(%v) Not Equal that(%v)", this.UpdatedAt, that1.UpdatedAt)
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return fmt.Errorf("CreatedAt this(%v) Not Equal that(%v)", this.CreatedAt, that1.CreatedAt)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *PlayerBill) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlayerBill)
	if !ok {
		that2, ok := that.(PlayerBill)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.PlayerID != that1.PlayerID {
		return false
	}
	if this.Before != that1.Before {
		return false
	}
	if this.Balance != that1.Balance {
		return false
	}
	if this.After != that1.After {
		return false
	}
	if this.Kind != that1.Kind {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Player) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	n1, err1 := github_com_kubegames_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_kubegames_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintPlayer(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	n2, err2 := github_com_kubegames_protobuf_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_kubegames_protobuf_types.SizeOfStdTime(m.UpdatedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintPlayer(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	if m.Roomctl != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Roomctl))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Pointctl != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Pointctl))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.IsRobot {
		i--
		if m.IsRobot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.Sign) > 0 {
		i -= len(m.Sign)
		copy(dAtA[i:], m.Sign)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Sign)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.City) > 0 {
		i -= len(m.City)
		copy(dAtA[i:], m.City)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.City)))
		i--
		dAtA[i] = 0x62
	}
	if m.Sex != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Sex))
		i--
		dAtA[i] = 0x58
	}
	if m.PlatformID != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.PlatformID))
		i--
		dAtA[i] = 0x50
	}
	if len(m.EquipmentCode) > 0 {
		i -= len(m.EquipmentCode)
		copy(dAtA[i:], m.EquipmentCode)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.EquipmentCode)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Nick) > 0 {
		i -= len(m.Nick)
		copy(dAtA[i:], m.Nick)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Nick)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Avatar) > 0 {
		i -= len(m.Avatar)
		copy(dAtA[i:], m.Avatar)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Avatar)))
		i--
		dAtA[i] = 0x32
	}
	if m.Chip != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Chip))
		i--
		dAtA[i] = 0x28
	}
	if m.Balance != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Balance))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x12
	}
	if m.PlayerID != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x48
	}
	n3, err3 := github_com_kubegames_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_kubegames_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintPlayer(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x42
	n4, err4 := github_com_kubegames_protobuf_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_kubegames_protobuf_types.SizeOfStdTime(m.UpdatedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintPlayer(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x3a
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PodName) > 0 {
		i -= len(m.PodName)
		copy(dAtA[i:], m.PodName)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.PodName)))
		i--
		dAtA[i] = 0x22
	}
	if m.RoomID != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.RoomID))
		i--
		dAtA[i] = 0x18
	}
	if m.GameID != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerID != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayerRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n5, err5 := github_com_kubegames_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_kubegames_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintPlayer(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x62
	n6, err6 := github_com_kubegames_protobuf_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_kubegames_protobuf_types.SizeOfStdTime(m.UpdatedAt):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintPlayer(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x5a
	if m.Balance != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Balance))
		i--
		dAtA[i] = 0x50
	}
	if m.GameID != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x48
	}
	if m.RoomID != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.RoomID))
		i--
		dAtA[i] = 0x40
	}
	if m.OutputAmount != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.OutputAmount))
		i--
		dAtA[i] = 0x38
	}
	if m.DrawAmount != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.DrawAmount))
		i--
		dAtA[i] = 0x30
	}
	if m.BetsAmount != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.BetsAmount))
		i--
		dAtA[i] = 0x28
	}
	if m.ProfitAmount != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.ProfitAmount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.GameNum) > 0 {
		i -= len(m.GameNum)
		copy(dAtA[i:], m.GameNum)
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.GameNum)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PlayerID != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlayerBill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerBill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerBill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n7, err7 := github_com_kubegames_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_kubegames_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintPlayer(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x42
	n8, err8 := github_com_kubegames_protobuf_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_kubegames_protobuf_types.SizeOfStdTime(m.UpdatedAt):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintPlayer(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x3a
	if m.Kind != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x30
	}
	if m.After != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.After))
		i--
		dAtA[i] = 0x28
	}
	if m.Balance != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Balance))
		i--
		dAtA[i] = 0x20
	}
	if m.Before != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Before))
		i--
		dAtA[i] = 0x18
	}
	if m.PlayerID != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.PlayerID))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlayer(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPlayer(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlayer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovPlayer(uint64(m.PlayerID))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.Balance != 0 {
		n += 1 + sovPlayer(uint64(m.Balance))
	}
	if m.Chip != 0 {
		n += 1 + sovPlayer(uint64(m.Chip))
	}
	l = len(m.Avatar)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Nick)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.EquipmentCode)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.PlatformID != 0 {
		n += 1 + sovPlayer(uint64(m.PlatformID))
	}
	if m.Sex != 0 {
		n += 1 + sovPlayer(uint64(m.Sex))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.IsRobot {
		n += 2
	}
	if m.Pointctl != 0 {
		n += 2 + sovPlayer(uint64(m.Pointctl))
	}
	if m.Roomctl != 0 {
		n += 2 + sovPlayer(uint64(m.Roomctl))
	}
	l = github_com_kubegames_protobuf_types.SizeOfStdTime(m.UpdatedAt)
	n += 2 + l + sovPlayer(uint64(l))
	l = github_com_kubegames_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 2 + l + sovPlayer(uint64(l))
	if m.Version != 0 {
		n += 2 + sovPlayer(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerID != 0 {
		n += 1 + sovPlayer(uint64(m.PlayerID))
	}
	if m.GameID != 0 {
		n += 1 + sovPlayer(uint64(m.GameID))
	}
	if m.RoomID != 0 {
		n += 1 + sovPlayer(uint64(m.RoomID))
	}
	l = len(m.PodName)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = github_com_kubegames_protobuf_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovPlayer(uint64(l))
	l = github_com_kubegames_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovPlayer(uint64(l))
	if m.Version != 0 {
		n += 1 + sovPlayer(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	if m.PlayerID != 0 {
		n += 1 + sovPlayer(uint64(m.PlayerID))
	}
	l = len(m.GameNum)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.ProfitAmount != 0 {
		n += 1 + sovPlayer(uint64(m.ProfitAmount))
	}
	if m.BetsAmount != 0 {
		n += 1 + sovPlayer(uint64(m.BetsAmount))
	}
	if m.DrawAmount != 0 {
		n += 1 + sovPlayer(uint64(m.DrawAmount))
	}
	if m.OutputAmount != 0 {
		n += 1 + sovPlayer(uint64(m.OutputAmount))
	}
	if m.RoomID != 0 {
		n += 1 + sovPlayer(uint64(m.RoomID))
	}
	if m.GameID != 0 {
		n += 1 + sovPlayer(uint64(m.GameID))
	}
	if m.Balance != 0 {
		n += 1 + sovPlayer(uint64(m.Balance))
	}
	l = github_com_kubegames_protobuf_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovPlayer(uint64(l))
	l = github_com_kubegames_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovPlayer(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerBill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlayer(uint64(m.Id))
	}
	if m.PlayerID != 0 {
		n += 1 + sovPlayer(uint64(m.PlayerID))
	}
	if m.Before != 0 {
		n += 1 + sovPlayer(uint64(m.Before))
	}
	if m.Balance != 0 {
		n += 1 + sovPlayer(uint64(m.Balance))
	}
	if m.After != 0 {
		n += 1 + sovPlayer(uint64(m.After))
	}
	if m.Kind != 0 {
		n += 1 + sovPlayer(uint64(m.Kind))
	}
	l = github_com_kubegames_protobuf_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovPlayer(uint64(l))
	l = github_com_kubegames_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovPlayer(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPlayer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlayer(x uint64) (n int) {
	return sovPlayer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chip", wireType)
			}
			m.Chip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chip |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Avatar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nick = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipmentCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EquipmentCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformID", wireType)
			}
			m.PlatformID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRobot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRobot = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pointctl", wireType)
			}
			m.Pointctl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pointctl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roomctl", wireType)
			}
			m.Roomctl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roomctl |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_kubegames_protobuf_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_kubegames_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			m.RoomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_kubegames_protobuf_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_kubegames_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameNum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameNum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfitAmount", wireType)
			}
			m.ProfitAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProfitAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetsAmount", wireType)
			}
			m.BetsAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetsAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawAmount", wireType)
			}
			m.DrawAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrawAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputAmount", wireType)
			}
			m.OutputAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			m.RoomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_kubegames_protobuf_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_kubegames_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerBill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerBill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerBill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerID", wireType)
			}
			m.PlayerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			m.Before = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Before |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			m.After = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.After |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= PlayerBill_BillKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_kubegames_protobuf_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_kubegames_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlayer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlayer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPlayer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPlayer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPlayer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlayer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPlayer = fmt.Errorf("proto: unexpected end of group")
)
