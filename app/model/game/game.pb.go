// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/model/game/game.proto

package game

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//游戏基础信息
type Game struct {
	//自增ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" xorm:"not null pk autoincr comment('room id') BigInt"`
	//游戏ID
	GameID uint32 `protobuf:"varint,2,opt,name=gameID,proto3" json:"gameID,omitempty" xorm:"unique comment('游戏ID') BigInt"`
	//游戏名称
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" xorm:"comment('游戏名称') Varchar(255)"`
	//状态
	Status bool `protobuf:"varint,4,opt,name=status,proto3" json:"status,omitempty" xorm:"comment('状态，false停止，true运行') Bool"`
	//镜像
	Image string `protobuf:"bytes,5,opt,name=image,proto3" json:"image,omitempty" xorm:"comment('镜像') Varchar(255)"`
	//运行副本数
	Replicas uint32 `protobuf:"varint,6,opt,name=replicas,proto3" json:"replicas,omitempty" xorm:"comment('运行副本数') Int"`
	//端口
	Port uint32 `protobuf:"varint,7,opt,name=port,proto3" json:"port,omitempty" xorm:"comment('端口') Int"`
	//启动命令
	Commonds []string `protobuf:"bytes,8,rep,name=commonds,proto3" json:"commonds,omitempty" xorm:"comment('启动命令')"`
	//最大可用 cpu (1000 = 1cpu)
	Cpu uint32 `protobuf:"varint,9,opt,name=cpu,proto3" json:"cpu,omitempty" xorm:"comment('最大可用 cpu (1000 = 1cpu)') BigInt"`
	//最大可用内存 memory (1=1Mi)
	Memory uint32 `protobuf:"varint,10,opt,name=memory,proto3" json:"memory,omitempty" xorm:"comment('最大可用内存 memory (1=1Mi)') BigInt"`
	//游戏篇日志
	Config               *GameConfig `protobuf:"bytes,11,opt,name=config,proto3" json:"config,omitempty" xorm:"-"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte      `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32       `json:"-" xorm:"-" gorm:"-"`
}

func (m *Game) Reset()         { *m = Game{} }
func (m *Game) String() string { return proto.CompactTextString(m) }
func (*Game) ProtoMessage()    {}
func (*Game) Descriptor() ([]byte, []int) {
	return fileDescriptor_7512a9e7b9924428, []int{0}
}
func (m *Game) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Game) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Game.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Game) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Game.Merge(m, src)
}
func (m *Game) XXX_Size() int {
	return m.Size()
}
func (m *Game) XXX_DiscardUnknown() {
	xxx_messageInfo_Game.DiscardUnknown(m)
}

var xxx_messageInfo_Game proto.InternalMessageInfo

//游戏配置
type GameConfig struct {
	//自增ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" xorm:"not null pk autoincr comment('room id') BigInt"`
	//游戏名称
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" xorm:"comment('游戏名称') Varchar(255)"`
	//游戏ID
	GameID uint32 `protobuf:"varint,3,opt,name=gameID,proto3" json:"gameID,omitempty" xorm:"unique comment('游戏ID') BigInt"`
	//游戏平台地址
	Platform string `protobuf:"bytes,4,opt,name=platform,proto3" json:"platform,omitempty" xorm:"comment('游戏平台地址') Varchar(255)"`
	//最多进入人数
	MaxPeople uint32 `protobuf:"varint,5,opt,name=maxPeople,proto3" json:"maxPeople,omitempty" xorm:"comment('最多进入人数') BigInt"`
	//运行模式
	Runmode              string   `protobuf:"bytes,6,opt,name=runmode,proto3" json:"runmode,omitempty" xorm:"comment('运行模式') Varchar(255)"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *GameConfig) Reset()         { *m = GameConfig{} }
func (m *GameConfig) String() string { return proto.CompactTextString(m) }
func (*GameConfig) ProtoMessage()    {}
func (*GameConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_7512a9e7b9924428, []int{1}
}
func (m *GameConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameConfig.Merge(m, src)
}
func (m *GameConfig) XXX_Size() int {
	return m.Size()
}
func (m *GameConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_GameConfig.DiscardUnknown(m)
}

var xxx_messageInfo_GameConfig proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Game)(nil), "model_game.Game")
	proto.RegisterType((*GameConfig)(nil), "model_game.GameConfig")
}

func init() { proto.RegisterFile("app/model/game/game.proto", fileDescriptor_7512a9e7b9924428) }

var fileDescriptor_7512a9e7b9924428 = []byte{
	// 778 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0x51, 0x4b, 0xeb, 0x66,
	0x18, 0xc7, 0x4d, 0x5b, 0x6b, 0xfb, 0x3a, 0x6f, 0x72, 0x31, 0xb2, 0x31, 0x92, 0x97, 0xc0, 0x68,
	0xca, 0x66, 0x6b, 0xdd, 0xca, 0x36, 0xa7, 0x0e, 0xa2, 0x63, 0xf4, 0x42, 0xd8, 0x8a, 0x78, 0xb1,
	0x9b, 0x91, 0xa6, 0x69, 0x0d, 0x26, 0x79, 0xb3, 0x34, 0x01, 0x77, 0xa7, 0x0c, 0xc7, 0x26, 0x8e,
	0x3a, 0x98, 0x20, 0x5b, 0x77, 0xe1, 0xe6, 0xb0, 0xb0, 0x49, 0x85, 0xc1, 0xf0, 0x78, 0x3c, 0x78,
	0xeb, 0xdd, 0x39, 0x9f, 0x20, 0x68, 0x8f, 0x6f, 0xf5, 0x5c, 0x79, 0xc8, 0x27, 0x38, 0xe4, 0x4d,
	0x6b, 0x3d, 0xb5, 0x9c, 0x1b, 0xcf, 0x4d, 0x69, 0xf2, 0x3e, 0xff, 0xdf, 0xf3, 0xbc, 0xcf, 0xf3,
	0xfc, 0x03, 0xde, 0x92, 0x4c, 0x33, 0xad, 0xa3, 0xa2, 0xa2, 0xa5, 0xcb, 0x92, 0xae, 0x90, 0x9f,
	0x94, 0x69, 0x21, 0x1b, 0xd1, 0x80, 0xbc, 0xfe, 0xc6, 0x7f, 0xf3, 0x36, 0xf4, 0xc3, 0x34, 0xb5,
	0x90, 0x2e, 0xa3, 0x32, 0x4a, 0x93, 0xf3, 0x82, 0x53, 0x22, 0x4f, 0x41, 0x34, 0xbf, 0x15, 0x05,
	0x91, 0x2f, 0x24, 0x5d, 0xa1, 0x73, 0x20, 0xa4, 0x16, 0x19, 0x0a, 0x52, 0x42, 0x44, 0xfc, 0xc4,
	0x73, 0xb9, 0xec, 0x32, 0xb2, 0xf4, 0x09, 0xde, 0x40, 0x36, 0x34, 0x1c, 0x4d, 0x83, 0xe6, 0x12,
	0x94, 0x1c, 0x1b, 0xa9, 0x86, 0x6c, 0x41, 0x19, 0xe9, 0xba, 0x62, 0xd8, 0x42, 0xc2, 0x42, 0x48,
	0x87, 0x6a, 0x31, 0x91, 0x84, 0xa2, 0x5a, 0xce, 0x19, 0x36, 0x9f, 0x0f, 0xa9, 0x45, 0x7a, 0x16,
	0x44, 0xfd, 0xec, 0xb9, 0x59, 0x26, 0x04, 0x29, 0x61, 0x44, 0x7c, 0xdf, 0x73, 0x39, 0x21, 0xc0,
	0x39, 0x86, 0xfa, 0xad, 0xa3, 0x74, 0x01, 0xad, 0xc3, 0xc3, 0xd6, 0x8f, 0xd5, 0xdc, 0xec, 0x2d,
	0x42, 0x5b, 0x4b, 0xcf, 0x80, 0x88, 0x21, 0xe9, 0x0a, 0x13, 0x86, 0x94, 0x10, 0x17, 0xd3, 0x9e,
	0xcb, 0xbd, 0x17, 0x30, 0x7a, 0xc4, 0x78, 0xf3, 0xe7, 0xcb, 0xbd, 0x83, 0x44, 0x12, 0x2e, 0x48,
	0x96, 0xbc, 0x28, 0x59, 0xc2, 0x78, 0x36, 0x9b, 0xe4, 0xf3, 0x44, 0x4c, 0xcf, 0x83, 0x68, 0xc5,
	0x96, 0x6c, 0xa7, 0xc2, 0x44, 0x20, 0x25, 0xc4, 0xc4, 0x49, 0xcf, 0xe5, 0x3e, 0xee, 0xc1, 0x5c,
	0xae, 0xff, 0xdf, 0x5a, 0x59, 0xbd, 0x3e, 0xde, 0x28, 0x49, 0x5a, 0x45, 0xc1, 0xab, 0xb5, 0xd6,
	0xfe, 0x9f, 0xd7, 0xc7, 0x1b, 0xb6, 0xe5, 0x28, 0x57, 0x27, 0x9b, 0x57, 0x3b, 0x1b, 0x7e, 0x71,
	0x08, 0x69, 0x7c, 0xbe, 0xcd, 0xa2, 0x3f, 0x03, 0x83, 0xaa, 0x2e, 0x95, 0x15, 0x66, 0x90, 0xd4,
	0x96, 0xf4, 0x5c, 0xee, 0xdd, 0x1e, 0xe8, 0xb3, 0xad, 0x1a, 0xfe, 0xbe, 0x7a, 0xa7, 0xaa, 0x40,
	0x47, 0x7f, 0x0e, 0x62, 0x96, 0x62, 0x6a, 0xaa, 0x2c, 0x55, 0x98, 0x28, 0xe9, 0x51, 0x3f, 0x46,
	0x90, 0x1d, 0xff, 0xd4, 0x68, 0xd5, 0xfe, 0x6d, 0x6d, 0xf9, 0x57, 0x24, 0x0d, 0xba, 0x91, 0xd2,
	0x1f, 0x82, 0x88, 0x89, 0x2c, 0x9b, 0x19, 0x22, 0x08, 0xe8, 0xb9, 0xdc, 0x3b, 0xbd, 0x77, 0xfb,
	0xa7, 0x81, 0xab, 0x7f, 0x75, 0x94, 0x24, 0x9a, 0x9e, 0x06, 0x31, 0xff, 0x1c, 0x19, 0xc5, 0x0a,
	0x13, 0x83, 0x61, 0x21, 0x2e, 0xf2, 0x9e, 0xcb, 0xb1, 0x3d, 0x4a, 0xbc, 0xd9, 0xc0, 0xeb, 0x75,
	0xfc, 0xcb, 0xa3, 0x8b, 0x87, 0xbb, 0x89, 0x24, 0x9f, 0xbf, 0xd1, 0xd0, 0x73, 0x20, 0x2c, 0x9b,
	0x0e, 0x13, 0x27, 0x49, 0x3f, 0xf5, 0x5c, 0xee, 0xa3, 0xde, 0xb9, 0xd4, 0x56, 0xf0, 0xee, 0x1e,
	0xae, 0x36, 0x2e, 0x7f, 0xad, 0x43, 0xd9, 0x74, 0xa0, 0x90, 0x19, 0x1b, 0x1b, 0x83, 0x53, 0x30,
	0x23, 0x9b, 0x4e, 0xf2, 0xd6, 0xa8, 0x7d, 0x0e, 0xbd, 0x00, 0xa2, 0xba, 0xa2, 0x23, 0xeb, 0x3b,
	0x06, 0x10, 0xe2, 0xb4, 0xe7, 0x72, 0x13, 0xaf, 0x20, 0xe2, 0x1f, 0xd6, 0xf0, 0xfe, 0x36, 0x0c,
	0x34, 0x50, 0xc8, 0x4c, 0x65, 0xe6, 0xd4, 0xdb, 0xd0, 0x36, 0x8d, 0x9e, 0x04, 0x51, 0x19, 0x19,
	0x25, 0xb5, 0xcc, 0x0c, 0x43, 0x4a, 0x18, 0x1e, 0x7f, 0x33, 0xd5, 0x35, 0x46, 0xca, 0x5f, 0xf9,
	0x19, 0x72, 0x2a, 0xbe, 0xe1, 0xb9, 0x5c, 0x2c, 0xc8, 0x37, 0xca, 0xe7, 0xdb, 0x1a, 0xfe, 0x71,
	0x18, 0x80, 0x6e, 0xd0, 0xeb, 0x74, 0x47, 0x67, 0xaf, 0x43, 0xf7, 0xd9, 0xeb, 0xae, 0xc5, 0xc2,
	0xf7, 0xb0, 0xd8, 0x57, 0x20, 0x66, 0x6a, 0x92, 0x5d, 0x42, 0x96, 0x4e, 0xfc, 0x11, 0x17, 0xb3,
	0x9e, 0xcb, 0x65, 0xfa, 0x97, 0xf3, 0xe0, 0x3f, 0x5c, 0x3d, 0xc0, 0xb5, 0x03, 0xfc, 0xc7, 0xca,
	0x9d, 0xa2, 0x6e, 0x30, 0xf4, 0x1c, 0x88, 0xeb, 0xd2, 0xf2, 0x97, 0x0a, 0x32, 0xb5, 0xc0, 0x1e,
	0x23, 0xfd, 0xaf, 0xe8, 0x0f, 0xf4, 0xb7, 0xab, 0x93, 0xdf, 0xf1, 0xda, 0xdf, 0x17, 0x47, 0x47,
	0xc1, 0x76, 0x77, 0xca, 0xeb, 0x12, 0xe8, 0x1c, 0x18, 0xb2, 0x1c, 0xc3, 0x1f, 0x1c, 0xf1, 0x49,
	0xff, 0x7e, 0x05, 0x3e, 0x69, 0xd5, 0x77, 0xf0, 0xf1, 0x5d, 0xc7, 0x75, 0xf4, 0xe2, 0xfc, 0xe9,
	0x39, 0x3b, 0x70, 0x76, 0xce, 0x52, 0xcf, 0xcf, 0x59, 0xaa, 0xde, 0x64, 0xa9, 0xd3, 0x26, 0x4b,
	0x3d, 0x69, 0xb2, 0xd4, 0x59, 0x93, 0xa5, 0xb6, 0x9f, 0xb2, 0x03, 0x5f, 0x8f, 0x97, 0x55, 0x7b,
	0xd1, 0x29, 0xa4, 0x64, 0xa4, 0xa7, 0x97, 0x9c, 0x82, 0xe2, 0x77, 0xa9, 0xd2, 0xfd, 0x37, 0xba,
	0x28, 0x69, 0x5a, 0xfa, 0xe5, 0x0f, 0x6f, 0x21, 0x4a, 0x3e, 0xa3, 0x1f, 0xbc, 0x08, 0x00, 0x00,
	0xff, 0xff, 0xab, 0x07, 0x4a, 0x40, 0x91, 0x05, 0x00, 0x00,
}

func (this *Game) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Game)
	if !ok {
		that2, ok := that.(Game)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Game")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Game but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Game but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.GameID != that1.GameID {
		return fmt.Errorf("GameID this(%v) Not Equal that(%v)", this.GameID, that1.GameID)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Image != that1.Image {
		return fmt.Errorf("Image this(%v) Not Equal that(%v)", this.Image, that1.Image)
	}
	if this.Replicas != that1.Replicas {
		return fmt.Errorf("Replicas this(%v) Not Equal that(%v)", this.Replicas, that1.Replicas)
	}
	if this.Port != that1.Port {
		return fmt.Errorf("Port this(%v) Not Equal that(%v)", this.Port, that1.Port)
	}
	if len(this.Commonds) != len(that1.Commonds) {
		return fmt.Errorf("Commonds this(%v) Not Equal that(%v)", len(this.Commonds), len(that1.Commonds))
	}
	for i := range this.Commonds {
		if this.Commonds[i] != that1.Commonds[i] {
			return fmt.Errorf("Commonds this[%v](%v) Not Equal that[%v](%v)", i, this.Commonds[i], i, that1.Commonds[i])
		}
	}
	if this.Cpu != that1.Cpu {
		return fmt.Errorf("Cpu this(%v) Not Equal that(%v)", this.Cpu, that1.Cpu)
	}
	if this.Memory != that1.Memory {
		return fmt.Errorf("Memory this(%v) Not Equal that(%v)", this.Memory, that1.Memory)
	}
	if !this.Config.Equal(that1.Config) {
		return fmt.Errorf("Config this(%v) Not Equal that(%v)", this.Config, that1.Config)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Game) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Game)
	if !ok {
		that2, ok := that.(Game)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.GameID != that1.GameID {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Image != that1.Image {
		return false
	}
	if this.Replicas != that1.Replicas {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if len(this.Commonds) != len(that1.Commonds) {
		return false
	}
	for i := range this.Commonds {
		if this.Commonds[i] != that1.Commonds[i] {
			return false
		}
	}
	if this.Cpu != that1.Cpu {
		return false
	}
	if this.Memory != that1.Memory {
		return false
	}
	if !this.Config.Equal(that1.Config) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GameConfig) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GameConfig)
	if !ok {
		that2, ok := that.(GameConfig)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GameConfig")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GameConfig but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GameConfig but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.GameID != that1.GameID {
		return fmt.Errorf("GameID this(%v) Not Equal that(%v)", this.GameID, that1.GameID)
	}
	if this.Platform != that1.Platform {
		return fmt.Errorf("Platform this(%v) Not Equal that(%v)", this.Platform, that1.Platform)
	}
	if this.MaxPeople != that1.MaxPeople {
		return fmt.Errorf("MaxPeople this(%v) Not Equal that(%v)", this.MaxPeople, that1.MaxPeople)
	}
	if this.Runmode != that1.Runmode {
		return fmt.Errorf("Runmode this(%v) Not Equal that(%v)", this.Runmode, that1.Runmode)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GameConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GameConfig)
	if !ok {
		that2, ok := that.(GameConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.GameID != that1.GameID {
		return false
	}
	if this.Platform != that1.Platform {
		return false
	}
	if this.MaxPeople != that1.MaxPeople {
		return false
	}
	if this.Runmode != that1.Runmode {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Game) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&game.Game{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "GameID: "+fmt.Sprintf("%#v", this.GameID)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	s = append(s, "Replicas: "+fmt.Sprintf("%#v", this.Replicas)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Commonds: "+fmt.Sprintf("%#v", this.Commonds)+",\n")
	s = append(s, "Cpu: "+fmt.Sprintf("%#v", this.Cpu)+",\n")
	s = append(s, "Memory: "+fmt.Sprintf("%#v", this.Memory)+",\n")
	if this.Config != nil {
		s = append(s, "Config: "+fmt.Sprintf("%#v", this.Config)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GameConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&game.GameConfig{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "GameID: "+fmt.Sprintf("%#v", this.GameID)+",\n")
	s = append(s, "Platform: "+fmt.Sprintf("%#v", this.Platform)+",\n")
	s = append(s, "MaxPeople: "+fmt.Sprintf("%#v", this.MaxPeople)+",\n")
	s = append(s, "Runmode: "+fmt.Sprintf("%#v", this.Runmode)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringGame(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Game) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Game) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Game) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGame(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Memory != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x50
	}
	if m.Cpu != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Cpu))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Commonds) > 0 {
		for iNdEx := len(m.Commonds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Commonds[iNdEx])
			copy(dAtA[i:], m.Commonds[iNdEx])
			i = encodeVarintGame(dAtA, i, uint64(len(m.Commonds[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Port != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x38
	}
	if m.Replicas != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Replicas))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintGame(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGame(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GameID != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Runmode) > 0 {
		i -= len(m.Runmode)
		copy(dAtA[i:], m.Runmode)
		i = encodeVarintGame(dAtA, i, uint64(len(m.Runmode)))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxPeople != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.MaxPeople))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintGame(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x22
	}
	if m.GameID != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGame(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGame(dAtA []byte, offset int, v uint64) int {
	offset -= sovGame(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Game) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	if m.GameID != 0 {
		n += 1 + sovGame(uint64(m.GameID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Status {
		n += 2
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Replicas != 0 {
		n += 1 + sovGame(uint64(m.Replicas))
	}
	if m.Port != 0 {
		n += 1 + sovGame(uint64(m.Port))
	}
	if len(m.Commonds) > 0 {
		for _, s := range m.Commonds {
			l = len(s)
			n += 1 + l + sovGame(uint64(l))
		}
	}
	if m.Cpu != 0 {
		n += 1 + sovGame(uint64(m.Cpu))
	}
	if m.Memory != 0 {
		n += 1 + sovGame(uint64(m.Memory))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.GameID != 0 {
		n += 1 + sovGame(uint64(m.GameID))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.MaxPeople != 0 {
		n += 1 + sovGame(uint64(m.MaxPeople))
	}
	l = len(m.Runmode)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovGame(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGame(x uint64) (n int) {
	return sovGame(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Game) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Game: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Game: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			m.Replicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Replicas |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commonds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commonds = append(m.Commonds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			m.Cpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cpu |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &GameConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPeople", wireType)
			}
			m.MaxPeople = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPeople |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runmode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGame
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runmode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGame(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGame
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGame
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGame
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGame
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGame        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGame          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGame = fmt.Errorf("proto: unexpected end of group")
)
