// code generated by github.com/kubegames/protoc-gen-xorm. DO NOT EDIT.

package game

import "xorm.io/xorm"

//insert one
func InsertGame(session *xorm.Session, model Game) (int64, error) {
	return session.InsertOne(&model)
}

//insert array
func InsertGames(session *xorm.Session, models []*Game) (int64, error) {
	return session.Insert(&models)
}

//delete
func DeleteGame(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	for _, where := range wheres {
		session = where(session)
	}
	return session.Delete(&Game{})
}

//update
func UpdateGame(session *xorm.Session, updates map[string]interface{}, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	session = session.Table(&Game{})
	for _, where := range wheres {
		session = where(session)
	}
	return session.Update(updates)
}

//find
func FindGame(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result Game, ok bool, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	ok, err = session.Get(&result)
	if err != nil {
		return result, false, err
	}
	return result, ok, nil
}

//finds
func FindGames(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result []*Game, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	if err = session.Find(&result); err != nil {
		return nil, err
	}
	return result, nil
}

//page
func PageGame(session *xorm.Session, page, size int, wheres ...func(*xorm.Session) *xorm.Session) (total int64, result []*Game, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	total, err = session.Limit(size, (page-1)*size).FindAndCount(&result)
	if err != nil {
		return total, nil, err
	}
	return total, result, nil
}

//insert one
func InsertGameConfig(session *xorm.Session, model GameConfig) (int64, error) {
	return session.InsertOne(&model)
}

//insert array
func InsertGameConfigs(session *xorm.Session, models []*GameConfig) (int64, error) {
	return session.Insert(&models)
}

//delete
func DeleteGameConfig(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	for _, where := range wheres {
		session = where(session)
	}
	return session.Delete(&GameConfig{})
}

//update
func UpdateGameConfig(session *xorm.Session, updates map[string]interface{}, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	session = session.Table(&GameConfig{})
	for _, where := range wheres {
		session = where(session)
	}
	return session.Update(updates)
}

//find
func FindGameConfig(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result GameConfig, ok bool, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	ok, err = session.Get(&result)
	if err != nil {
		return result, false, err
	}
	return result, ok, nil
}

//finds
func FindGameConfigs(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result []*GameConfig, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	if err = session.Find(&result); err != nil {
		return nil, err
	}
	return result, nil
}

//page
func PageGameConfig(session *xorm.Session, page, size int, wheres ...func(*xorm.Session) *xorm.Session) (total int64, result []*GameConfig, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	total, err = session.Limit(size, (page-1)*size).FindAndCount(&result)
	if err != nil {
		return total, nil, err
	}
	return total, result, nil
}
