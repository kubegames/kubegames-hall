// code generated by github.com/kubegames/protoc-gen-xorm. DO NOT EDIT.

package room

import "xorm.io/xorm"

//insert one
func InsertRoom(session *xorm.Session, model Room) (int64, error) {
	return session.InsertOne(&model)
}

//insert array
func InsertRooms(session *xorm.Session, models []*Room) (int64, error) {
	return session.Insert(&models)
}

//delete
func DeleteRoom(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	for _, where := range wheres {
		session = where(session)
	}
	return session.Delete(&Room{})
}

//update
func UpdateRoom(session *xorm.Session, updates map[string]interface{}, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	session = session.Table(&Room{})
	for _, where := range wheres {
		session = where(session)
	}
	return session.Update(updates)
}

//find
func FindRoom(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result Room, ok bool, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	ok, err = session.Get(&result)
	if err != nil {
		return result, false, err
	}
	return result, ok, nil
}

//finds
func FindRooms(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result []*Room, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	if err = session.Find(&result); err != nil {
		return nil, err
	}
	return result, nil
}

//page
func PageRoom(session *xorm.Session, page, size int, wheres ...func(*xorm.Session) *xorm.Session) (total int64, result []*Room, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	total, err = session.Limit(size, (page-1)*size).FindAndCount(&result)
	if err != nil {
		return total, nil, err
	}
	return total, result, nil
}

//insert one
func InsertRobotConfig(session *xorm.Session, model RobotConfig) (int64, error) {
	return session.InsertOne(&model)
}

//insert array
func InsertRobotConfigs(session *xorm.Session, models []*RobotConfig) (int64, error) {
	return session.Insert(&models)
}

//delete
func DeleteRobotConfig(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	for _, where := range wheres {
		session = where(session)
	}
	return session.Delete(&RobotConfig{})
}

//update
func UpdateRobotConfig(session *xorm.Session, updates map[string]interface{}, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	session = session.Table(&RobotConfig{})
	for _, where := range wheres {
		session = where(session)
	}
	return session.Update(updates)
}

//find
func FindRobotConfig(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result RobotConfig, ok bool, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	ok, err = session.Get(&result)
	if err != nil {
		return result, false, err
	}
	return result, ok, nil
}

//finds
func FindRobotConfigs(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result []*RobotConfig, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	if err = session.Find(&result); err != nil {
		return nil, err
	}
	return result, nil
}

//page
func PageRobotConfig(session *xorm.Session, page, size int, wheres ...func(*xorm.Session) *xorm.Session) (total int64, result []*RobotConfig, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	total, err = session.Limit(size, (page-1)*size).FindAndCount(&result)
	if err != nil {
		return total, nil, err
	}
	return total, result, nil
}

//insert one
func InsertServerRunRoom(session *xorm.Session, model ServerRunRoom) (int64, error) {
	return session.InsertOne(&model)
}

//insert array
func InsertServerRunRooms(session *xorm.Session, models []*ServerRunRoom) (int64, error) {
	return session.Insert(&models)
}

//delete
func DeleteServerRunRoom(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	for _, where := range wheres {
		session = where(session)
	}
	return session.Delete(&ServerRunRoom{})
}

//update
func UpdateServerRunRoom(session *xorm.Session, updates map[string]interface{}, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	session = session.Table(&ServerRunRoom{})
	for _, where := range wheres {
		session = where(session)
	}
	return session.Update(updates)
}

//find
func FindServerRunRoom(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result ServerRunRoom, ok bool, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	ok, err = session.Get(&result)
	if err != nil {
		return result, false, err
	}
	return result, ok, nil
}

//finds
func FindServerRunRooms(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result []*ServerRunRoom, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	if err = session.Find(&result); err != nil {
		return nil, err
	}
	return result, nil
}

//page
func PageServerRunRoom(session *xorm.Session, page, size int, wheres ...func(*xorm.Session) *xorm.Session) (total int64, result []*ServerRunRoom, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	total, err = session.Limit(size, (page-1)*size).FindAndCount(&result)
	if err != nil {
		return total, nil, err
	}
	return total, result, nil
}

//insert one
func InsertServerLockRoom(session *xorm.Session, model ServerLockRoom) (int64, error) {
	return session.InsertOne(&model)
}

//insert array
func InsertServerLockRooms(session *xorm.Session, models []*ServerLockRoom) (int64, error) {
	return session.Insert(&models)
}

//delete
func DeleteServerLockRoom(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	for _, where := range wheres {
		session = where(session)
	}
	return session.Delete(&ServerLockRoom{})
}

//update
func UpdateServerLockRoom(session *xorm.Session, updates map[string]interface{}, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	session = session.Table(&ServerLockRoom{})
	for _, where := range wheres {
		session = where(session)
	}
	return session.Update(updates)
}

//find
func FindServerLockRoom(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result ServerLockRoom, ok bool, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	ok, err = session.Get(&result)
	if err != nil {
		return result, false, err
	}
	return result, ok, nil
}

//finds
func FindServerLockRooms(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result []*ServerLockRoom, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	if err = session.Find(&result); err != nil {
		return nil, err
	}
	return result, nil
}

//page
func PageServerLockRoom(session *xorm.Session, page, size int, wheres ...func(*xorm.Session) *xorm.Session) (total int64, result []*ServerLockRoom, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	total, err = session.Limit(size, (page-1)*size).FindAndCount(&result)
	if err != nil {
		return total, nil, err
	}
	return total, result, nil
}

//insert one
func InsertRoomPool(session *xorm.Session, model RoomPool) (int64, error) {
	return session.InsertOne(&model)
}

//insert array
func InsertRoomPools(session *xorm.Session, models []*RoomPool) (int64, error) {
	return session.Insert(&models)
}

//delete
func DeleteRoomPool(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	for _, where := range wheres {
		session = where(session)
	}
	return session.Delete(&RoomPool{})
}

//update
func UpdateRoomPool(session *xorm.Session, updates map[string]interface{}, wheres ...func(*xorm.Session) *xorm.Session) (int64, error) {
	session = session.Table(&RoomPool{})
	for _, where := range wheres {
		session = where(session)
	}
	return session.Update(updates)
}

//find
func FindRoomPool(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result RoomPool, ok bool, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	ok, err = session.Get(&result)
	if err != nil {
		return result, false, err
	}
	return result, ok, nil
}

//finds
func FindRoomPools(session *xorm.Session, wheres ...func(*xorm.Session) *xorm.Session) (result []*RoomPool, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	if err = session.Find(&result); err != nil {
		return nil, err
	}
	return result, nil
}

//page
func PageRoomPool(session *xorm.Session, page, size int, wheres ...func(*xorm.Session) *xorm.Session) (total int64, result []*RoomPool, err error) {
	for _, where := range wheres {
		session = where(session)
	}
	total, err = session.Limit(size, (page-1)*size).FindAndCount(&result)
	if err != nil {
		return total, nil, err
	}
	return total, result, nil
}
