// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/model/room/room.proto

package room

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	github_com_kubegames_kubegames_ctl_protobuf_types "github.com/kubegames/kubegames-ctl/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//房间基础信息
type Room struct {
	//自增ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" xorm:"not null pk autoincr comment('room id') BigInt"`
	//业主ID
	PlatformID uint32 `protobuf:"varint,2,opt,name=platformID,proto3" json:"platformID,omitempty" xorm:"index comment('平台ID') BigInt"`
	//状态
	Status bool `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty" xorm:"comment('状态，false关闭，true开放') Bool"`
	//房间ID
	RoomID uint32 `protobuf:"varint,4,opt,name=roomID,proto3" json:"roomID,omitempty" xorm:"unique comment('房间ID') BigInt"`
	//游戏ID
	GameID uint32 `protobuf:"varint,5,opt,name=gameID,proto3" json:"gameID,omitempty" xorm:"index comment('游戏ID') BigInt"`
	//房间等级
	Level int32 `protobuf:"varint,6,opt,name=level,proto3" json:"level,omitempty" xorm:"comment('房间等级') Int"`
	//游戏房间名称
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty" xorm:"comment('游戏房间名称') Varchar(255)"`
	//房间明税率
	Rate uint32 `protobuf:"varint,8,opt,name=rate,proto3" json:"rate,omitempty" xorm:"comment('房间明税率') BigInt"`
	//入场限制
	EntranceRestrictions uint32 `protobuf:"varint,9,opt,name=entranceRestrictions,proto3" json:"entranceRestrictions,omitempty" xorm:"comment('入场限制') BigInt"`
	//底注
	BottomNote int32 `protobuf:"varint,10,opt,name=bottomNote,proto3" json:"bottomNote,omitempty" xorm:"comment('底注') Int"`
	//高级配置
	AdviceConfig string `protobuf:"bytes,11,opt,name=adviceConfig,proto3" json:"adviceConfig,omitempty" xorm:"comment('高级配置') Varchar(255)"`
	//点控状态
	PointStatus int32 `protobuf:"varint,12,opt,name=pointStatus,proto3" json:"pointStatus,omitempty" xorm:"comment('点控状态') Int"`
	//最大人数
	MaxPeople int32 `protobuf:"varint,13,opt,name=maxPeople,proto3" json:"maxPeople,omitempty" xorm:"comment('最大人数') Int"`
	//最小开赛人数
	MinPeople int32 `protobuf:"varint,14,opt,name=minPeople,proto3" json:"minPeople,omitempty" xorm:"comment('最小开赛人数') Int"`
	//是否允许关闭
	IsAllowClose bool `protobuf:"varint,15,opt,name=isAllowClose,proto3" json:"isAllowClose,omitempty" xorm:"comment('是否允许关闭') Bool"`
	//是否开启机器人
	IsOpenAiRobot bool `protobuf:"varint,16,opt,name=isOpenAiRobot,proto3" json:"isOpenAiRobot,omitempty" xorm:"comment('是否开启机器人') Bool"`
	//是否开启跨业主匹配
	IsOpenCrossPlatformMatch bool `protobuf:"varint,17,opt,name=isOpenCrossPlatformMatch,proto3" json:"isOpenCrossPlatformMatch,omitempty" xorm:"comment('是否开启跨业主匹配') Bool"`
	//允许的平台
	AllowPlatformID []uint32 `protobuf:"varint,18,rep,packed,name=allowPlatformID,proto3" json:"allowPlatformID,omitempty" xorm:"comment('允许的平台')"`
	//是否允许自动创建桌子
	IsAllowAutoCreateTable bool `protobuf:"varint,19,opt,name=isAllowAutoCreateTable,proto3" json:"isAllowAutoCreateTable,omitempty" xorm:"comment('是否允许自动创建桌子') Bool"`
	//机器人配置
	Robot []*RobotConfig `protobuf:"bytes,20,rep,name=robot,proto3" json:"robot,omitempty" xorm:"comment('机器人配置')"`
	//最大金额
	RobotMaxBalance int64 `protobuf:"varint,21,opt,name=robotMaxBalance,proto3" json:"robotMaxBalance,omitempty" xorm:"comment('机器人携带最大金额') BigInt"`
	//最小金额
	RobotMinBalance int64 `protobuf:"varint,22,opt,name=robotMinBalance,proto3" json:"robotMinBalance,omitempty" xorm:"comment('机器人携带最小金额') BigInt"`
	//绑定房间水池
	RoomPoolID           int64    `protobuf:"varint,23,opt,name=RoomPoolID,proto3" json:"RoomPoolID,omitempty" xorm:"comment('绑定房间水池') BigInt"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *Room) Reset()         { *m = Room{} }
func (m *Room) String() string { return proto.CompactTextString(m) }
func (*Room) ProtoMessage()    {}
func (*Room) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ec507aece0bce7, []int{0}
}
func (m *Room) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Room) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Room.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Room) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Room.Merge(m, src)
}
func (m *Room) XXX_Size() int {
	return m.Size()
}
func (m *Room) XXX_DiscardUnknown() {
	xxx_messageInfo_Room.DiscardUnknown(m)
}

var xxx_messageInfo_Room proto.InternalMessageInfo

//机器人配置
type RobotConfig struct {
	//最小人数
	Min uint32 `protobuf:"varint,1,opt,name=Min,proto3" json:"Min,omitempty"`
	//最大人数
	Max                  uint32   `protobuf:"varint,2,opt,name=Max,proto3" json:"Max,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *RobotConfig) Reset()         { *m = RobotConfig{} }
func (m *RobotConfig) String() string { return proto.CompactTextString(m) }
func (*RobotConfig) ProtoMessage()    {}
func (*RobotConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ec507aece0bce7, []int{1}
}
func (m *RobotConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RobotConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RobotConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RobotConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RobotConfig.Merge(m, src)
}
func (m *RobotConfig) XXX_Size() int {
	return m.Size()
}
func (m *RobotConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RobotConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RobotConfig proto.InternalMessageInfo

//服务运行的房间
type ServerRunRoom struct {
	//自增ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" xorm:"not null pk autoincr comment('room id') BigInt"`
	//房间 ID
	RoomID uint32 `protobuf:"varint,2,opt,name=roomID,proto3" json:"roomID,omitempty" xorm:"unique(roomid_ip) comment('房间 ID') BigInt"`
	//游戏服务地址
	Ip                   string   `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty" xorm:"unique(roomid_ip) comment('游戏服务地址') Varchar(255)"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *ServerRunRoom) Reset()         { *m = ServerRunRoom{} }
func (m *ServerRunRoom) String() string { return proto.CompactTextString(m) }
func (*ServerRunRoom) ProtoMessage()    {}
func (*ServerRunRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ec507aece0bce7, []int{2}
}
func (m *ServerRunRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerRunRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerRunRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerRunRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerRunRoom.Merge(m, src)
}
func (m *ServerRunRoom) XXX_Size() int {
	return m.Size()
}
func (m *ServerRunRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerRunRoom.DiscardUnknown(m)
}

var xxx_messageInfo_ServerRunRoom proto.InternalMessageInfo

//房间和游戏绑定
type ServerLockRoom struct {
	//自增ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" xorm:"not null pk autoincr comment('room id') BigInt"`
	//房间 ID
	RoomID uint32 `protobuf:"varint,2,opt,name=roomID,proto3" json:"roomID,omitempty" xorm:"unique comment('房间 ID') BigInt"`
	//游戏服务地址
	Ip string `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty" xorm:"comment('游戏服务地址') Varchar(255)"`
	//创建时间
	CreatedAt            time.Time `protobuf:"bytes,4,opt,name=createdAt,proto3,stdtime" json:"createdAt" xorm:"created"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte    `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32     `json:"-" xorm:"-" gorm:"-"`
}

func (m *ServerLockRoom) Reset()         { *m = ServerLockRoom{} }
func (m *ServerLockRoom) String() string { return proto.CompactTextString(m) }
func (*ServerLockRoom) ProtoMessage()    {}
func (*ServerLockRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ec507aece0bce7, []int{3}
}
func (m *ServerLockRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServerLockRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServerLockRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServerLockRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerLockRoom.Merge(m, src)
}
func (m *ServerLockRoom) XXX_Size() int {
	return m.Size()
}
func (m *ServerLockRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerLockRoom.DiscardUnknown(m)
}

var xxx_messageInfo_ServerLockRoom proto.InternalMessageInfo

//房间水池
type RoomPool struct {
	//自增ID
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" xorm:"not null pk autoincr comment('room id') BigInt"`
	//血池名称
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" xorm:"unique comment('血池名称') Varchar(255)"`
	//业主ID
	PlatformID uint32 `protobuf:"varint,3,opt,name=platformID,proto3" json:"platformID,omitempty" xorm:"index comment('平台ID') BigInt"`
	//水位线
	WaterLevelLine       int64    `protobuf:"varint,4,opt,name=WaterLevelLine,proto3" json:"WaterLevelLine,omitempty" xorm:"comment('水位线') BigInt"`
	XXX_NoUnkeyedLiteral struct{} `json:"-" xorm:"-" gorm:"-"`
	XXX_unrecognized     []byte   `json:"-" xorm:"-" gorm:"-"`
	XXX_sizecache        int32    `json:"-" xorm:"-" gorm:"-"`
}

func (m *RoomPool) Reset()         { *m = RoomPool{} }
func (m *RoomPool) String() string { return proto.CompactTextString(m) }
func (*RoomPool) ProtoMessage()    {}
func (*RoomPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_59ec507aece0bce7, []int{4}
}
func (m *RoomPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoomPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomPool.Merge(m, src)
}
func (m *RoomPool) XXX_Size() int {
	return m.Size()
}
func (m *RoomPool) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomPool.DiscardUnknown(m)
}

var xxx_messageInfo_RoomPool proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Room)(nil), "model_room.Room")
	proto.RegisterType((*RobotConfig)(nil), "model_room.RobotConfig")
	proto.RegisterType((*ServerRunRoom)(nil), "model_room.ServerRunRoom")
	proto.RegisterType((*ServerLockRoom)(nil), "model_room.ServerLockRoom")
	proto.RegisterType((*RoomPool)(nil), "model_room.RoomPool")
}

func init() { proto.RegisterFile("app/model/room/room.proto", fileDescriptor_59ec507aece0bce7) }

var fileDescriptor_59ec507aece0bce7 = []byte{
	// 1356 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x96, 0xdf, 0x6f, 0xd3, 0x56,
	0x14, 0xc7, 0x71, 0xd2, 0x76, 0xf4, 0x96, 0x16, 0xe6, 0x31, 0xf0, 0xaa, 0x29, 0xf6, 0x2c, 0xb1,
	0x24, 0x02, 0x92, 0xd1, 0xad, 0x13, 0x9b, 0x78, 0xa0, 0x69, 0xd0, 0x16, 0xc6, 0x8f, 0x2e, 0x54,
	0x20, 0x4d, 0x9a, 0x90, 0x93, 0xdc, 0xa6, 0x16, 0xb6, 0x6f, 0x70, 0x6e, 0x58, 0x1f, 0xc3, 0xb4,
	0x8a, 0x0e, 0xf5, 0x47, 0x90, 0x86, 0x28, 0x50, 0x24, 0x98, 0x36, 0x5a, 0x6d, 0x02, 0x82, 0x60,
	0xac, 0x84, 0x02, 0xaf, 0x3c, 0xee, 0x2f, 0xf0, 0xa0, 0xab, 0x9d, 0xe6, 0x65, 0x4c, 0xfe, 0x0b,
	0x26, 0x5f, 0xe7, 0x87, 0x63, 0x52, 0xd0, 0x34, 0x5e, 0x2a, 0xf7, 0xe6, 0x9e, 0xcf, 0x39, 0xe7,
	0x7b, 0xef, 0x3d, 0xe7, 0x80, 0x77, 0x84, 0x4c, 0x26, 0x2c, 0xa3, 0x14, 0x94, 0xc2, 0x2a, 0x42,
	0x32, 0xf9, 0x13, 0xca, 0xa8, 0x08, 0x23, 0x1a, 0x90, 0xe5, 0xe3, 0xd6, 0x4a, 0x2f, 0x67, 0x6d,
	0x93, 0xc4, 0x44, 0x38, 0x8d, 0xd2, 0x28, 0x4c, 0x7e, 0x4f, 0xe4, 0x46, 0xc8, 0x7f, 0xf6, 0xee,
	0x5e, 0x7f, 0x63, 0x07, 0x4a, 0x4b, 0xb0, 0xb1, 0x07, 0x8b, 0x32, 0xcc, 0x62, 0x41, 0xce, 0xd8,
	0x1b, 0xf9, 0xbf, 0x7b, 0x40, 0x5b, 0x1c, 0x21, 0x99, 0x8e, 0x01, 0x8f, 0x98, 0x62, 0x28, 0x8e,
	0x0a, 0xb4, 0x45, 0x3e, 0x31, 0x35, 0xb6, 0x7f, 0x0c, 0xa9, 0xf2, 0xa7, 0xbc, 0x82, 0x30, 0xa7,
	0xe4, 0x24, 0x89, 0xcb, 0x9c, 0xe0, 0x84, 0x1c, 0x46, 0xa2, 0x92, 0x54, 0xb9, 0x24, 0x92, 0x65,
	0xa8, 0xe0, 0x80, 0xdf, 0x8a, 0x86, 0x13, 0x53, 0xfe, 0x20, 0x17, 0x11, 0xd3, 0x31, 0x05, 0xf3,
	0x71, 0x8f, 0x98, 0xa2, 0xbf, 0x00, 0x20, 0x23, 0x09, 0x78, 0x04, 0xa9, 0x72, 0x2c, 0xca, 0x78,
	0x38, 0x2a, 0xd0, 0x1d, 0xd9, 0x6e, 0x6a, 0xac, 0xdf, 0x46, 0x8a, 0x4a, 0x0a, 0x8e, 0x35, 0x18,
	0xfa, 0xfd, 0x3b, 0xfa, 0x4c, 0x31, 0x16, 0x75, 0x40, 0x1c, 0xe6, 0xf4, 0x30, 0xe8, 0xc8, 0x62,
	0x01, 0xe7, 0xb2, 0x8c, 0x97, 0xa3, 0x02, 0xeb, 0x23, 0x7b, 0x4c, 0x8d, 0xdd, 0x6d, 0x83, 0xea,
	0x88, 0xf2, 0xd9, 0x7b, 0x46, 0xfe, 0xf4, 0xf3, 0xa5, 0xc9, 0x11, 0x41, 0xca, 0x42, 0x7d, 0xfc,
	0x4e, 0xe5, 0xc2, 0x8d, 0xe7, 0x4b, 0x93, 0x58, 0xcd, 0x41, 0x7d, 0x29, 0x6f, 0xfc, 0xf0, 0xc8,
	0x62, 0x23, 0x24, 0xf1, 0xf1, 0x2a, 0x8b, 0x8e, 0x82, 0x0e, 0x2b, 0xf6, 0x58, 0x94, 0x69, 0x23,
	0xe1, 0xed, 0x30, 0x35, 0x36, 0x60, 0x53, 0x73, 0x8a, 0x78, 0x32, 0x07, 0x1b, 0xf1, 0x19, 0x13,
	0x8f, 0x2b, 0x17, 0xee, 0x36, 0xc5, 0x57, 0xb5, 0xa5, 0x07, 0x41, 0x47, 0x5a, 0x90, 0x61, 0x2c,
	0xca, 0xb4, 0xbf, 0x22, 0x49, 0x63, 0x71, 0xd1, 0x98, 0x98, 0x69, 0x86, 0xd8, 0xa6, 0xf4, 0x1e,
	0xd0, 0x2e, 0xc1, 0x53, 0x50, 0x62, 0x3a, 0x38, 0x2a, 0xd0, 0x1e, 0x79, 0xdf, 0xd4, 0x58, 0xde,
	0x95, 0x9f, 0x1d, 0x42, 0xf9, 0xc6, 0xf7, 0xe5, 0xd2, 0xbc, 0x3f, 0xc8, 0x11, 0x73, 0xdb, 0x88,
	0x8e, 0x81, 0x36, 0x45, 0x90, 0x21, 0xf3, 0x06, 0x47, 0x05, 0x3a, 0x23, 0xfd, 0xa6, 0xc6, 0xee,
	0x72, 0x1b, 0x13, 0xd7, 0x36, 0x42, 0x2f, 0x4c, 0x95, 0xe7, 0x8b, 0xfe, 0x20, 0x77, 0x54, 0x50,
	0x93, 0xa3, 0x82, 0x1a, 0xe8, 0xeb, 0xef, 0x0f, 0xf2, 0x71, 0x82, 0xa0, 0xf7, 0x82, 0x36, 0x55,
	0xc0, 0x90, 0x59, 0xef, 0x56, 0xc4, 0x15, 0x87, 0x31, 0x3b, 0x5d, 0x5e, 0x98, 0x2e, 0x4f, 0x9f,
	0x71, 0x24, 0x43, 0x2c, 0xe9, 0xaf, 0xc1, 0x66, 0xa8, 0x60, 0x55, 0x50, 0x92, 0x30, 0x0e, 0xb3,
	0x58, 0x15, 0x93, 0x58, 0x44, 0x4a, 0x96, 0xe9, 0x24, 0xc4, 0xa0, 0xa9, 0xb1, 0xdb, 0x5c, 0x44,
	0x7d, 0xfc, 0x67, 0x7d, 0xae, 0x54, 0xb9, 0x58, 0xd0, 0x27, 0xee, 0x39, 0x70, 0x2d, 0x31, 0xf4,
	0x5e, 0x00, 0x12, 0x08, 0x63, 0x24, 0x1f, 0x42, 0x18, 0x32, 0x80, 0xc8, 0xc5, 0x99, 0x1a, 0xfb,
	0xae, 0x1b, 0x5a, 0x3a, 0x6f, 0xdc, 0x59, 0xa8, 0x09, 0xe5, 0xb0, 0xa1, 0x8f, 0x80, 0x0d, 0x42,
	0xea, 0x94, 0x98, 0x84, 0x83, 0x48, 0x19, 0x11, 0xd3, 0x4c, 0x17, 0x51, 0x2d, 0x6c, 0x6a, 0xec,
	0x76, 0x17, 0xa3, 0xf2, 0xeb, 0x6c, 0xb9, 0x34, 0x5f, 0x19, 0x9f, 0x2a, 0x3f, 0xbc, 0xf9, 0x82,
	0x5e, 0x4d, 0x10, 0xfa, 0x73, 0xd0, 0x95, 0x41, 0xa2, 0x82, 0x8f, 0xd8, 0xd7, 0x74, 0xc3, 0x9a,
	0xc7, 0x58, 0xfe, 0xf6, 0xbe, 0x31, 0x3d, 0x6f, 0x5f, 0xd6, 0x5a, 0x74, 0x4e, 0x53, 0x3a, 0x0a,
	0x3a, 0x65, 0x61, 0x6c, 0x08, 0xa2, 0x8c, 0x04, 0x99, 0xee, 0xb5, 0xaf, 0xc3, 0x5c, 0x5e, 0xff,
	0x69, 0x7e, 0xa5, 0x54, 0x32, 0xce, 0x17, 0x6b, 0x9c, 0x86, 0x21, 0xbd, 0x1f, 0x74, 0xca, 0xa2,
	0x52, 0xa5, 0xf4, 0x10, 0x4a, 0xcb, 0xc3, 0x9c, 0xcb, 0xeb, 0xc5, 0x19, 0x7d, 0x29, 0xbf, 0xfa,
	0xdb, 0x65, 0x37, 0xab, 0x66, 0x4e, 0x7f, 0x09, 0x36, 0x88, 0xd9, 0x01, 0x49, 0x42, 0xdf, 0x0c,
	0x4a, 0x28, 0x0b, 0x99, 0x8d, 0xe4, 0x0d, 0xee, 0x34, 0x35, 0x36, 0xe8, 0xc6, 0xcd, 0xde, 0xd2,
	0x0b, 0xd7, 0xf5, 0xf1, 0xd3, 0xab, 0x37, 0x17, 0xed, 0x17, 0x58, 0x7f, 0x74, 0x4d, 0x08, 0xfa,
	0x28, 0xe8, 0x16, 0xb3, 0x87, 0x33, 0x50, 0x19, 0x10, 0xe3, 0x28, 0x81, 0x30, 0xb3, 0x89, 0x30,
	0x3f, 0x30, 0x35, 0x76, 0x47, 0x6b, 0xe6, 0x52, 0x5e, 0x2f, 0xdc, 0x32, 0xe6, 0x4a, 0xfa, 0xc5,
	0x85, 0x95, 0x52, 0xa9, 0x8e, 0x6d, 0xc6, 0xd0, 0x2a, 0x60, 0xec, 0x85, 0x41, 0x15, 0x65, 0xb3,
	0x43, 0xd5, 0x0a, 0x72, 0x50, 0xc0, 0xc9, 0x51, 0xe6, 0x4d, 0xe2, 0xe2, 0x63, 0x53, 0x63, 0xfb,
	0x5e, 0xe2, 0x62, 0xf5, 0xf7, 0x85, 0x95, 0xc5, 0x4b, 0x2b, 0x8b, 0x0f, 0xf4, 0xc9, 0xfb, 0x95,
	0xf1, 0xa9, 0xba, 0xa3, 0x35, 0xb9, 0xf4, 0x61, 0xb0, 0x51, 0xb0, 0x32, 0x1b, 0x6a, 0x94, 0x3b,
	0x9a, 0xf3, 0x06, 0xba, 0x23, 0xdb, 0x4c, 0x8d, 0x7d, 0xef, 0x85, 0xbb, 0x6e, 0x69, 0x53, 0xbe,
	0xf4, 0x9d, 0x5d, 0xf1, 0xfc, 0x41, 0x3e, 0xee, 0xb6, 0xa6, 0x4f, 0x82, 0x2d, 0x55, 0xb1, 0x06,
	0x72, 0x18, 0x0d, 0xaa, 0x50, 0xc0, 0x70, 0x58, 0x48, 0x48, 0x90, 0x79, 0x8b, 0xa4, 0xe0, 0xa8,
	0xcc, 0x2d, 0x95, 0x5f, 0x3d, 0xf3, 0x8b, 0x7e, 0x76, 0x41, 0x9f, 0xb8, 0xac, 0x3f, 0x28, 0x19,
	0xd7, 0x26, 0xf5, 0x1b, 0x85, 0x7a, 0x16, 0x6b, 0x80, 0xe9, 0x61, 0xd0, 0xae, 0x92, 0x73, 0xd8,
	0xcc, 0x79, 0x03, 0x5d, 0x7d, 0x5b, 0x43, 0x8d, 0x46, 0x13, 0x22, 0xca, 0xda, 0xd7, 0xbc, 0x65,
	0x4a, 0xf5, 0x43, 0xa9, 0x3d, 0x14, 0x3e, 0x6e, 0xc3, 0xe8, 0x04, 0xd8, 0x48, 0x3e, 0x0e, 0x0a,
	0x63, 0x11, 0x41, 0xb2, 0x9e, 0x32, 0xf3, 0x36, 0x47, 0x05, 0xbc, 0x91, 0xdd, 0xa6, 0xc6, 0x7e,
	0xb4, 0x16, 0xc6, 0x28, 0x94, 0xf4, 0xc5, 0xeb, 0xf6, 0xfd, 0xae, 0x9c, 0x39, 0x57, 0xf9, 0xf1,
	0x8a, 0xa3, 0x28, 0xb8, 0x81, 0x0d, 0x1f, 0xa2, 0x52, 0xf3, 0xb1, 0xe5, 0xbf, 0xf8, 0x28, 0xce,
	0xac, 0xe5, 0xa3, 0x0e, 0xa4, 0x0f, 0x03, 0x60, 0xb5, 0xc7, 0x21, 0x84, 0xa4, 0x58, 0x94, 0xd9,
	0x4a, 0xf0, 0xad, 0xea, 0x45, 0xf9, 0xc1, 0x39, 0xfd, 0xe6, 0xa5, 0x6a, 0x81, 0x2c, 0xde, 0x35,
	0x6e, 0x5f, 0x75, 0xf6, 0xb3, 0x06, 0x82, 0xdf, 0x05, 0xba, 0x1c, 0xaa, 0xd2, 0x9b, 0x80, 0xf7,
	0xa0, 0xa8, 0x90, 0xbe, 0xdb, 0x1d, 0xb7, 0x3e, 0xc9, 0x8a, 0x30, 0x66, 0xb7, 0xcd, 0xb8, 0xf5,
	0xc9, 0x8f, 0x7b, 0x40, 0xf7, 0x11, 0xa8, 0x9e, 0x82, 0x6a, 0x3c, 0xa7, 0xbc, 0xee, 0x66, 0x3d,
	0x54, 0xef, 0x84, 0x76, 0xa3, 0x76, 0x68, 0x67, 0x77, 0xc2, 0x80, 0xf5, 0xb3, 0x98, 0x3a, 0x2e,
	0x66, 0x82, 0xee, 0xa6, 0xc8, 0xb5, 0xec, 0x8a, 0xc7, 0x80, 0x47, 0xcc, 0x90, 0x6e, 0xdd, 0x19,
	0xf9, 0xcc, 0xd4, 0xd8, 0xc1, 0x57, 0xd3, 0xec, 0x16, 0x35, 0x37, 0xa5, 0x9f, 0xbd, 0xa6, 0xcf,
	0x15, 0xf5, 0x2b, 0xf9, 0x17, 0x4a, 0xae, 0x47, 0xcc, 0xf0, 0x8f, 0x3d, 0xa0, 0xc7, 0xd6, 0xe1,
	0x00, 0x4a, 0x9e, 0x78, 0xdd, 0x42, 0xec, 0x73, 0x09, 0xe1, 0x28, 0x72, 0xad, 0x47, 0x82, 0xd6,
	0xd9, 0xef, 0x73, 0x64, 0xff, 0x92, 0x76, 0xfc, 0x8a, 0x5c, 0xe9, 0x61, 0xd0, 0x99, 0x24, 0x8f,
	0x34, 0x35, 0x80, 0xc9, 0x8c, 0xd2, 0xd5, 0xd7, 0x1b, 0xb2, 0x87, 0xb9, 0x50, 0x6d, 0x98, 0x0b,
	0x0d, 0xd7, 0x86, 0xb9, 0x48, 0xef, 0x13, 0x8d, 0x5d, 0x67, 0x6a, 0x6c, 0x4f, 0xd5, 0x9b, 0x6d,
	0xca, 0x17, 0xfe, 0x64, 0xa9, 0x78, 0x03, 0xc4, 0x3f, 0xf2, 0x80, 0xf5, 0xb5, 0xbb, 0xf8, 0x3a,
	0xb5, 0xdb, 0x5f, 0x9d, 0x42, 0x3c, 0x24, 0x6d, 0x47, 0x9d, 0x75, 0x2b, 0xb7, 0x7a, 0x2d, 0x6f,
	0xdc, 0xbe, 0xfa, 0xd2, 0x31, 0xa4, 0x79, 0x7a, 0xf4, 0xfe, 0xbf, 0xe9, 0xf1, 0x10, 0xe8, 0x39,
	0x26, 0x60, 0xa8, 0x1e, 0xb0, 0x86, 0xa5, 0x03, 0xa2, 0x02, 0x89, 0x96, 0xde, 0xd6, 0x6d, 0xb5,
	0x78, 0x77, 0xe5, 0xe1, 0x54, 0xb9, 0xf4, 0xd8, 0xc1, 0x72, 0x59, 0x47, 0x86, 0x9f, 0x3c, 0xf3,
	0xad, 0x7b, 0xfa, 0xcc, 0x47, 0xfd, 0xf3, 0xcc, 0x47, 0x2d, 0x2c, 0xfb, 0xa8, 0x27, 0xcb, 0x3e,
	0xea, 0x8f, 0x65, 0x1f, 0xf5, 0x74, 0xd9, 0x47, 0xcd, 0xfe, 0xe5, 0x5b, 0xf7, 0x55, 0x5f, 0x5a,
	0xc4, 0xa3, 0xb9, 0x44, 0x28, 0x89, 0xe4, 0xf0, 0x89, 0x5c, 0x02, 0x5a, 0x53, 0x5e, 0xb6, 0xf1,
	0xb5, 0x73, 0x54, 0x90, 0xa4, 0x70, 0xf3, 0x98, 0x9f, 0xe8, 0x20, 0x27, 0xfa, 0xe1, 0xbf, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x63, 0x2f, 0x3f, 0x4c, 0xff, 0x0b, 0x00, 0x00,
}

func (this *Room) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Room)
	if !ok {
		that2, ok := that.(Room)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Room")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Room but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Room but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.PlatformID != that1.PlatformID {
		return fmt.Errorf("PlatformID this(%v) Not Equal that(%v)", this.PlatformID, that1.PlatformID)
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.RoomID != that1.RoomID {
		return fmt.Errorf("RoomID this(%v) Not Equal that(%v)", this.RoomID, that1.RoomID)
	}
	if this.GameID != that1.GameID {
		return fmt.Errorf("GameID this(%v) Not Equal that(%v)", this.GameID, that1.GameID)
	}
	if this.Level != that1.Level {
		return fmt.Errorf("Level this(%v) Not Equal that(%v)", this.Level, that1.Level)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Rate != that1.Rate {
		return fmt.Errorf("Rate this(%v) Not Equal that(%v)", this.Rate, that1.Rate)
	}
	if this.EntranceRestrictions != that1.EntranceRestrictions {
		return fmt.Errorf("EntranceRestrictions this(%v) Not Equal that(%v)", this.EntranceRestrictions, that1.EntranceRestrictions)
	}
	if this.BottomNote != that1.BottomNote {
		return fmt.Errorf("BottomNote this(%v) Not Equal that(%v)", this.BottomNote, that1.BottomNote)
	}
	if this.AdviceConfig != that1.AdviceConfig {
		return fmt.Errorf("AdviceConfig this(%v) Not Equal that(%v)", this.AdviceConfig, that1.AdviceConfig)
	}
	if this.PointStatus != that1.PointStatus {
		return fmt.Errorf("PointStatus this(%v) Not Equal that(%v)", this.PointStatus, that1.PointStatus)
	}
	if this.MaxPeople != that1.MaxPeople {
		return fmt.Errorf("MaxPeople this(%v) Not Equal that(%v)", this.MaxPeople, that1.MaxPeople)
	}
	if this.MinPeople != that1.MinPeople {
		return fmt.Errorf("MinPeople this(%v) Not Equal that(%v)", this.MinPeople, that1.MinPeople)
	}
	if this.IsAllowClose != that1.IsAllowClose {
		return fmt.Errorf("IsAllowClose this(%v) Not Equal that(%v)", this.IsAllowClose, that1.IsAllowClose)
	}
	if this.IsOpenAiRobot != that1.IsOpenAiRobot {
		return fmt.Errorf("IsOpenAiRobot this(%v) Not Equal that(%v)", this.IsOpenAiRobot, that1.IsOpenAiRobot)
	}
	if this.IsOpenCrossPlatformMatch != that1.IsOpenCrossPlatformMatch {
		return fmt.Errorf("IsOpenCrossPlatformMatch this(%v) Not Equal that(%v)", this.IsOpenCrossPlatformMatch, that1.IsOpenCrossPlatformMatch)
	}
	if len(this.AllowPlatformID) != len(that1.AllowPlatformID) {
		return fmt.Errorf("AllowPlatformID this(%v) Not Equal that(%v)", len(this.AllowPlatformID), len(that1.AllowPlatformID))
	}
	for i := range this.AllowPlatformID {
		if this.AllowPlatformID[i] != that1.AllowPlatformID[i] {
			return fmt.Errorf("AllowPlatformID this[%v](%v) Not Equal that[%v](%v)", i, this.AllowPlatformID[i], i, that1.AllowPlatformID[i])
		}
	}
	if this.IsAllowAutoCreateTable != that1.IsAllowAutoCreateTable {
		return fmt.Errorf("IsAllowAutoCreateTable this(%v) Not Equal that(%v)", this.IsAllowAutoCreateTable, that1.IsAllowAutoCreateTable)
	}
	if len(this.Robot) != len(that1.Robot) {
		return fmt.Errorf("Robot this(%v) Not Equal that(%v)", len(this.Robot), len(that1.Robot))
	}
	for i := range this.Robot {
		if !this.Robot[i].Equal(that1.Robot[i]) {
			return fmt.Errorf("Robot this[%v](%v) Not Equal that[%v](%v)", i, this.Robot[i], i, that1.Robot[i])
		}
	}
	if this.RobotMaxBalance != that1.RobotMaxBalance {
		return fmt.Errorf("RobotMaxBalance this(%v) Not Equal that(%v)", this.RobotMaxBalance, that1.RobotMaxBalance)
	}
	if this.RobotMinBalance != that1.RobotMinBalance {
		return fmt.Errorf("RobotMinBalance this(%v) Not Equal that(%v)", this.RobotMinBalance, that1.RobotMinBalance)
	}
	if this.RoomPoolID != that1.RoomPoolID {
		return fmt.Errorf("RoomPoolID this(%v) Not Equal that(%v)", this.RoomPoolID, that1.RoomPoolID)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Room) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Room)
	if !ok {
		that2, ok := that.(Room)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.PlatformID != that1.PlatformID {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.RoomID != that1.RoomID {
		return false
	}
	if this.GameID != that1.GameID {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Rate != that1.Rate {
		return false
	}
	if this.EntranceRestrictions != that1.EntranceRestrictions {
		return false
	}
	if this.BottomNote != that1.BottomNote {
		return false
	}
	if this.AdviceConfig != that1.AdviceConfig {
		return false
	}
	if this.PointStatus != that1.PointStatus {
		return false
	}
	if this.MaxPeople != that1.MaxPeople {
		return false
	}
	if this.MinPeople != that1.MinPeople {
		return false
	}
	if this.IsAllowClose != that1.IsAllowClose {
		return false
	}
	if this.IsOpenAiRobot != that1.IsOpenAiRobot {
		return false
	}
	if this.IsOpenCrossPlatformMatch != that1.IsOpenCrossPlatformMatch {
		return false
	}
	if len(this.AllowPlatformID) != len(that1.AllowPlatformID) {
		return false
	}
	for i := range this.AllowPlatformID {
		if this.AllowPlatformID[i] != that1.AllowPlatformID[i] {
			return false
		}
	}
	if this.IsAllowAutoCreateTable != that1.IsAllowAutoCreateTable {
		return false
	}
	if len(this.Robot) != len(that1.Robot) {
		return false
	}
	for i := range this.Robot {
		if !this.Robot[i].Equal(that1.Robot[i]) {
			return false
		}
	}
	if this.RobotMaxBalance != that1.RobotMaxBalance {
		return false
	}
	if this.RobotMinBalance != that1.RobotMinBalance {
		return false
	}
	if this.RoomPoolID != that1.RoomPoolID {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RobotConfig) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RobotConfig)
	if !ok {
		that2, ok := that.(RobotConfig)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RobotConfig")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RobotConfig but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RobotConfig but is not nil && this == nil")
	}
	if this.Min != that1.Min {
		return fmt.Errorf("Min this(%v) Not Equal that(%v)", this.Min, that1.Min)
	}
	if this.Max != that1.Max {
		return fmt.Errorf("Max this(%v) Not Equal that(%v)", this.Max, that1.Max)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *RobotConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RobotConfig)
	if !ok {
		that2, ok := that.(RobotConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Min != that1.Min {
		return false
	}
	if this.Max != that1.Max {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ServerRunRoom) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ServerRunRoom)
	if !ok {
		that2, ok := that.(ServerRunRoom)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ServerRunRoom")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ServerRunRoom but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ServerRunRoom but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.RoomID != that1.RoomID {
		return fmt.Errorf("RoomID this(%v) Not Equal that(%v)", this.RoomID, that1.RoomID)
	}
	if this.Ip != that1.Ip {
		return fmt.Errorf("Ip this(%v) Not Equal that(%v)", this.Ip, that1.Ip)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ServerRunRoom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServerRunRoom)
	if !ok {
		that2, ok := that.(ServerRunRoom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.RoomID != that1.RoomID {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ServerLockRoom) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ServerLockRoom)
	if !ok {
		that2, ok := that.(ServerLockRoom)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ServerLockRoom")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ServerLockRoom but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ServerLockRoom but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.RoomID != that1.RoomID {
		return fmt.Errorf("RoomID this(%v) Not Equal that(%v)", this.RoomID, that1.RoomID)
	}
	if this.Ip != that1.Ip {
		return fmt.Errorf("Ip this(%v) Not Equal that(%v)", this.Ip, that1.Ip)
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return fmt.Errorf("CreatedAt this(%v) Not Equal that(%v)", this.CreatedAt, that1.CreatedAt)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ServerLockRoom) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ServerLockRoom)
	if !ok {
		that2, ok := that.(ServerLockRoom)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.RoomID != that1.RoomID {
		return false
	}
	if this.Ip != that1.Ip {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *RoomPool) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RoomPool)
	if !ok {
		that2, ok := that.(RoomPool)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RoomPool")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RoomPool but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RoomPool but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.PlatformID != that1.PlatformID {
		return fmt.Errorf("PlatformID this(%v) Not Equal that(%v)", this.PlatformID, that1.PlatformID)
	}
	if this.WaterLevelLine != that1.WaterLevelLine {
		return fmt.Errorf("WaterLevelLine this(%v) Not Equal that(%v)", this.WaterLevelLine, that1.WaterLevelLine)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *RoomPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoomPool)
	if !ok {
		that2, ok := that.(RoomPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.PlatformID != that1.PlatformID {
		return false
	}
	if this.WaterLevelLine != that1.WaterLevelLine {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Room) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 27)
	s = append(s, "&room.Room{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "PlatformID: "+fmt.Sprintf("%#v", this.PlatformID)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "RoomID: "+fmt.Sprintf("%#v", this.RoomID)+",\n")
	s = append(s, "GameID: "+fmt.Sprintf("%#v", this.GameID)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Rate: "+fmt.Sprintf("%#v", this.Rate)+",\n")
	s = append(s, "EntranceRestrictions: "+fmt.Sprintf("%#v", this.EntranceRestrictions)+",\n")
	s = append(s, "BottomNote: "+fmt.Sprintf("%#v", this.BottomNote)+",\n")
	s = append(s, "AdviceConfig: "+fmt.Sprintf("%#v", this.AdviceConfig)+",\n")
	s = append(s, "PointStatus: "+fmt.Sprintf("%#v", this.PointStatus)+",\n")
	s = append(s, "MaxPeople: "+fmt.Sprintf("%#v", this.MaxPeople)+",\n")
	s = append(s, "MinPeople: "+fmt.Sprintf("%#v", this.MinPeople)+",\n")
	s = append(s, "IsAllowClose: "+fmt.Sprintf("%#v", this.IsAllowClose)+",\n")
	s = append(s, "IsOpenAiRobot: "+fmt.Sprintf("%#v", this.IsOpenAiRobot)+",\n")
	s = append(s, "IsOpenCrossPlatformMatch: "+fmt.Sprintf("%#v", this.IsOpenCrossPlatformMatch)+",\n")
	s = append(s, "AllowPlatformID: "+fmt.Sprintf("%#v", this.AllowPlatformID)+",\n")
	s = append(s, "IsAllowAutoCreateTable: "+fmt.Sprintf("%#v", this.IsAllowAutoCreateTable)+",\n")
	if this.Robot != nil {
		s = append(s, "Robot: "+fmt.Sprintf("%#v", this.Robot)+",\n")
	}
	s = append(s, "RobotMaxBalance: "+fmt.Sprintf("%#v", this.RobotMaxBalance)+",\n")
	s = append(s, "RobotMinBalance: "+fmt.Sprintf("%#v", this.RobotMinBalance)+",\n")
	s = append(s, "RoomPoolID: "+fmt.Sprintf("%#v", this.RoomPoolID)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RobotConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&room.RobotConfig{")
	s = append(s, "Min: "+fmt.Sprintf("%#v", this.Min)+",\n")
	s = append(s, "Max: "+fmt.Sprintf("%#v", this.Max)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServerRunRoom) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&room.ServerRunRoom{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "RoomID: "+fmt.Sprintf("%#v", this.RoomID)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ServerLockRoom) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&room.ServerLockRoom{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "RoomID: "+fmt.Sprintf("%#v", this.RoomID)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RoomPool) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&room.RoomPool{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "PlatformID: "+fmt.Sprintf("%#v", this.PlatformID)+",\n")
	s = append(s, "WaterLevelLine: "+fmt.Sprintf("%#v", this.WaterLevelLine)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringRoom(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Room) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Room) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Room) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoomPoolID != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.RoomPoolID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.RobotMinBalance != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.RobotMinBalance))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.RobotMaxBalance != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.RobotMaxBalance))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.Robot) > 0 {
		for iNdEx := len(m.Robot) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Robot[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRoom(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.IsAllowAutoCreateTable {
		i--
		if m.IsAllowAutoCreateTable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.AllowPlatformID) > 0 {
		dAtA2 := make([]byte, len(m.AllowPlatformID)*10)
		var j1 int
		for _, num := range m.AllowPlatformID {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintRoom(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.IsOpenCrossPlatformMatch {
		i--
		if m.IsOpenCrossPlatformMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.IsOpenAiRobot {
		i--
		if m.IsOpenAiRobot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.IsAllowClose {
		i--
		if m.IsAllowClose {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.MinPeople != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.MinPeople))
		i--
		dAtA[i] = 0x70
	}
	if m.MaxPeople != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.MaxPeople))
		i--
		dAtA[i] = 0x68
	}
	if m.PointStatus != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.PointStatus))
		i--
		dAtA[i] = 0x60
	}
	if len(m.AdviceConfig) > 0 {
		i -= len(m.AdviceConfig)
		copy(dAtA[i:], m.AdviceConfig)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.AdviceConfig)))
		i--
		dAtA[i] = 0x5a
	}
	if m.BottomNote != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.BottomNote))
		i--
		dAtA[i] = 0x50
	}
	if m.EntranceRestrictions != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.EntranceRestrictions))
		i--
		dAtA[i] = 0x48
	}
	if m.Rate != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Level != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x30
	}
	if m.GameID != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.GameID))
		i--
		dAtA[i] = 0x28
	}
	if m.RoomID != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.RoomID))
		i--
		dAtA[i] = 0x20
	}
	if m.Status {
		i--
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.PlatformID != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.PlatformID))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RobotConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RobotConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RobotConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Max != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.Max))
		i--
		dAtA[i] = 0x10
	}
	if m.Min != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.Min))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServerRunRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerRunRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerRunRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RoomID != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.RoomID))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ServerLockRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServerLockRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServerLockRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n3, err3 := github_com_kubegames_kubegames_ctl_protobuf_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_kubegames_kubegames_ctl_protobuf_types.SizeOfStdTime(m.CreatedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintRoom(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x22
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RoomID != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.RoomID))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoomPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoomPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WaterLevelLine != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.WaterLevelLine))
		i--
		dAtA[i] = 0x20
	}
	if m.PlatformID != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.PlatformID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRoom(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintRoom(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRoom(dAtA []byte, offset int, v uint64) int {
	offset -= sovRoom(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Room) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRoom(uint64(m.Id))
	}
	if m.PlatformID != 0 {
		n += 1 + sovRoom(uint64(m.PlatformID))
	}
	if m.Status {
		n += 2
	}
	if m.RoomID != 0 {
		n += 1 + sovRoom(uint64(m.RoomID))
	}
	if m.GameID != 0 {
		n += 1 + sovRoom(uint64(m.GameID))
	}
	if m.Level != 0 {
		n += 1 + sovRoom(uint64(m.Level))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.Rate != 0 {
		n += 1 + sovRoom(uint64(m.Rate))
	}
	if m.EntranceRestrictions != 0 {
		n += 1 + sovRoom(uint64(m.EntranceRestrictions))
	}
	if m.BottomNote != 0 {
		n += 1 + sovRoom(uint64(m.BottomNote))
	}
	l = len(m.AdviceConfig)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.PointStatus != 0 {
		n += 1 + sovRoom(uint64(m.PointStatus))
	}
	if m.MaxPeople != 0 {
		n += 1 + sovRoom(uint64(m.MaxPeople))
	}
	if m.MinPeople != 0 {
		n += 1 + sovRoom(uint64(m.MinPeople))
	}
	if m.IsAllowClose {
		n += 2
	}
	if m.IsOpenAiRobot {
		n += 3
	}
	if m.IsOpenCrossPlatformMatch {
		n += 3
	}
	if len(m.AllowPlatformID) > 0 {
		l = 0
		for _, e := range m.AllowPlatformID {
			l += sovRoom(uint64(e))
		}
		n += 2 + sovRoom(uint64(l)) + l
	}
	if m.IsAllowAutoCreateTable {
		n += 3
	}
	if len(m.Robot) > 0 {
		for _, e := range m.Robot {
			l = e.Size()
			n += 2 + l + sovRoom(uint64(l))
		}
	}
	if m.RobotMaxBalance != 0 {
		n += 2 + sovRoom(uint64(m.RobotMaxBalance))
	}
	if m.RobotMinBalance != 0 {
		n += 2 + sovRoom(uint64(m.RobotMinBalance))
	}
	if m.RoomPoolID != 0 {
		n += 2 + sovRoom(uint64(m.RoomPoolID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RobotConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Min != 0 {
		n += 1 + sovRoom(uint64(m.Min))
	}
	if m.Max != 0 {
		n += 1 + sovRoom(uint64(m.Max))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerRunRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRoom(uint64(m.Id))
	}
	if m.RoomID != 0 {
		n += 1 + sovRoom(uint64(m.RoomID))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServerLockRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRoom(uint64(m.Id))
	}
	if m.RoomID != 0 {
		n += 1 + sovRoom(uint64(m.RoomID))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	l = github_com_kubegames_kubegames_ctl_protobuf_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovRoom(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRoom(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRoom(uint64(l))
	}
	if m.PlatformID != 0 {
		n += 1 + sovRoom(uint64(m.PlatformID))
	}
	if m.WaterLevelLine != 0 {
		n += 1 + sovRoom(uint64(m.WaterLevelLine))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRoom(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRoom(x uint64) (n int) {
	return sovRoom(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Room) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Room: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Room: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformID", wireType)
			}
			m.PlatformID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			m.RoomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameID", wireType)
			}
			m.GameID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntranceRestrictions", wireType)
			}
			m.EntranceRestrictions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntranceRestrictions |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BottomNote", wireType)
			}
			m.BottomNote = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BottomNote |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdviceConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdviceConfig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointStatus", wireType)
			}
			m.PointStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PointStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPeople", wireType)
			}
			m.MaxPeople = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPeople |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPeople", wireType)
			}
			m.MinPeople = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinPeople |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllowClose", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllowClose = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOpenAiRobot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOpenAiRobot = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOpenCrossPlatformMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOpenCrossPlatformMatch = bool(v != 0)
		case 18:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllowPlatformID = append(m.AllowPlatformID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoom
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRoom
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRoom
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AllowPlatformID) == 0 {
					m.AllowPlatformID = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoom
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllowPlatformID = append(m.AllowPlatformID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPlatformID", wireType)
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllowAutoCreateTable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllowAutoCreateTable = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Robot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Robot = append(m.Robot, &RobotConfig{})
			if err := m.Robot[len(m.Robot)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotMaxBalance", wireType)
			}
			m.RobotMaxBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobotMaxBalance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotMinBalance", wireType)
			}
			m.RobotMinBalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobotMinBalance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomPoolID", wireType)
			}
			m.RoomPoolID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomPoolID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RobotConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RobotConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RobotConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			m.Min = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Min |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerRunRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerRunRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerRunRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			m.RoomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerLockRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerLockRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerLockRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomID", wireType)
			}
			m.RoomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_kubegames_kubegames_ctl_protobuf_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoom
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRoom
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformID", wireType)
			}
			m.PlatformID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaterLevelLine", wireType)
			}
			m.WaterLevelLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaterLevelLine |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoom(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRoom
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoom(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoom
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoom
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRoom
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRoom
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRoom
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRoom        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoom          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRoom = fmt.Errorf("proto: unexpected end of group")
)
